{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to the Xenia Emulator Logo image/svg+xml Xenia Emulator Logo 28-05-2019 SVG Remake of Xenia Logo by Kwasior/@ThisKwasior Xenia Wiki , the primary source of documentation for Xenia , an experimental Xbox 360 emulator. Game Compatibility Tab Navigation Use tabs in header for navigation Open Source This site is Open Source and licensed under LICENSE . The source (as Markdown) is hosted on GitHub . Please see README.md for details on hosting the docs locally and contributing. Helpful Links Quickstart Guide (Start Here!) Frequently Asked Questions Developer Guide Contribute to the Wiki","title":"Home"},{"location":"#home","text":"Welcome to the Xenia Emulator Logo image/svg+xml Xenia Emulator Logo 28-05-2019 SVG Remake of Xenia Logo by Kwasior/@ThisKwasior Xenia Wiki , the primary source of documentation for Xenia , an experimental Xbox 360 emulator. Game Compatibility Tab Navigation Use tabs in header for navigation Open Source This site is Open Source and licensed under LICENSE . The source (as Markdown) is hosted on GitHub . Please see README.md for details on hosting the docs locally and contributing. Helpful Links Quickstart Guide (Start Here!) Frequently Asked Questions Developer Guide Contribute to the Wiki","title":"Home"},{"location":"development/","text":"Contribute to Xenia So, you want to contribute to Xenia's development? Here are the steps you'll need to take to get started: Have a computer capable of running Xenia, and install the required system components: See System Requirements Learn the language An often overlooked aspect to newcomers is having an understanding of the language the project is written in. Xenia uses C++ 17 for development. If you don't know this language, you may learn the basics on YouTube , but it may take a while to get a full grasp of it. In addition, to submit your contributions, you'll need to know how to use Git . Here is a crash course on Git to help you out. Learn to build Xenia from source This step should give you all you need to start developing Xenia with Visual Studio on Windows or Codelite on Linux. Follow the style guide Run xb format before creating a pull request. When you're ready, fork Xenia on GitHub, and push your changes. Then create a pull request on GitHub. Click the New Pull Request button at the top right of the page: Click Compare Across Forks to compare with your fork: Select your own fork from the list: Review your selection. Make sure you have selected the correct branch. Click Create Pull Request to confirm your selection: Write a title and description for your pull request. When you're done, press Submit Pull Request","title":"Contribute to Xenia"},{"location":"development/#contribute-to-xenia","text":"So, you want to contribute to Xenia's development? Here are the steps you'll need to take to get started: Have a computer capable of running Xenia, and install the required system components: See System Requirements Learn the language An often overlooked aspect to newcomers is having an understanding of the language the project is written in. Xenia uses C++ 17 for development. If you don't know this language, you may learn the basics on YouTube , but it may take a while to get a full grasp of it. In addition, to submit your contributions, you'll need to know how to use Git . Here is a crash course on Git to help you out. Learn to build Xenia from source This step should give you all you need to start developing Xenia with Visual Studio on Windows or Codelite on Linux. Follow the style guide Run xb format before creating a pull request. When you're ready, fork Xenia on GitHub, and push your changes. Then create a pull request on GitHub. Click the New Pull Request button at the top right of the page: Click Compare Across Forks to compare with your fork: Select your own fork from the list: Review your selection. Make sure you have selected the correct branch. Click Create Pull Request to confirm your selection: Write a title and description for your pull request. When you're done, press Submit Pull Request","title":"Contribute to Xenia"},{"location":"development/building/","text":"https://github.com/xenia-project/xenia/blob/master/docs/building.md","title":"Building"},{"location":"development/building/#httpsgithubcomxenia-projectxeniablobmasterdocsbuildingmd","text":"","title":"https://github.com/xenia-project/xenia/blob/master/docs/building.md"},{"location":"development/for_developers/","text":"Does Xenia run on Linux or macOS? The project is designed to support non-Windows platforms but until it's running games it's not worth the maintenance burden. MacOS will likely remain unsupported until Apple supports Vulkan. There's only a few major pieces that need cleanup before a Linux port can proceed in earnest, listed with the cross-platform tag . Most of the code compiles with the latest Clang, and very few files have dependencies on Windows APIs (all of that is isolated to _win.cc files). Though the codebase is ready for the port, it's not a trivial task and anyone seeking to port it will need a deep understanding of Linux, X11, Vulkan, and Win32 (to ensure matching semantics). You should port it to Linux, then tons of developers will contribute! No, they won't, and that's not how things work. (I'm seriously told this once a week...) Think of it this way: the most important kind of contributor in this phase of the project is one who is capable of performing the porting work. If someone has this capability and feels so strongly about Linux support then they would be contributing to the porting efforts already. But otherwise they are nothing more than hypothetical members of our collective dreams. Why did you do X? Why not just use Y? You should use Y. NIH NIH NIH! Trust that I either have a good reason for what I did or have absolutely no reason for what I did. This is a large project that I've been working on for almost 5 years and in that time new compilers and language specs have been released, libraries have been created and died, and I've learned a lot. Constructive contributions and improvements are welcome. Have you heard of LLVM/asmjit/jitasm/luajit/etc? Yes, I have heard of them. In fact, I spent a long time trying them out: LLVM , libjit , asmjit . I did not find them acceptable for use in this project for various reasons. If for some reason you feel strongly otherwise, feel free to either contribute a new CPU backend . (some argument over an unimportant technical choice) In general: I don't care . That means I either really don't care and something is they way it is because that was convenient or that I don't care because it's not material to the goal of the project. There are a million important things that need to be done to get games running and going back and forth about unimportant orthogonal issues does not help. If you really do have a better way of doing something and can show it, contributions are welcome. Here's a short list of common ones: 'Why this xb stuff?' -- I like it, it helps me. If you want to manually execute commands have fun, nothing is stopping you. 'Why not just take the code from project X?' -- the point of this project is to build something different than previous emulator projects and learn while doing it. The easy way is almost never the best way and most certainly isn't as fun. 'Why not CMake?' -- I don't like CMake as it generates ugly Visual Studio projects. Premake does what I want (mostly) how I want it to. Hey I'm going to go modify every file in the project, ok? We welcome contributions, but please try to understand that we cannot accept changes that radically alter the structure or content of the code, especially if they are aesthetic and even more so if they are from someone who has not contributed before. If a pull request of this nature is denied that doesn't necessarily mean your help is not wanted, just that it may need to be more carefully applied.","title":"Does Xenia run on Linux or macOS?"},{"location":"development/for_developers/#does-xenia-run-on-linux-or-macos","text":"The project is designed to support non-Windows platforms but until it's running games it's not worth the maintenance burden. MacOS will likely remain unsupported until Apple supports Vulkan. There's only a few major pieces that need cleanup before a Linux port can proceed in earnest, listed with the cross-platform tag . Most of the code compiles with the latest Clang, and very few files have dependencies on Windows APIs (all of that is isolated to _win.cc files). Though the codebase is ready for the port, it's not a trivial task and anyone seeking to port it will need a deep understanding of Linux, X11, Vulkan, and Win32 (to ensure matching semantics).","title":"Does Xenia run on Linux or macOS?"},{"location":"development/for_developers/#you-should-port-it-to-linux-then-tons-of-developers-will-contribute","text":"No, they won't, and that's not how things work. (I'm seriously told this once a week...) Think of it this way: the most important kind of contributor in this phase of the project is one who is capable of performing the porting work. If someone has this capability and feels so strongly about Linux support then they would be contributing to the porting efforts already. But otherwise they are nothing more than hypothetical members of our collective dreams.","title":"You should port it to Linux, then tons of developers will contribute!"},{"location":"development/for_developers/#why-did-you-do-x-why-not-just-use-y-you-should-use-y-nih-nih-nih","text":"Trust that I either have a good reason for what I did or have absolutely no reason for what I did. This is a large project that I've been working on for almost 5 years and in that time new compilers and language specs have been released, libraries have been created and died, and I've learned a lot. Constructive contributions and improvements are welcome.","title":"Why did you do X? Why not just use Y? You should use Y. NIH NIH NIH!"},{"location":"development/for_developers/#have-you-heard-of-llvmasmjitjitasmluajitetc","text":"Yes, I have heard of them. In fact, I spent a long time trying them out: LLVM , libjit , asmjit . I did not find them acceptable for use in this project for various reasons. If for some reason you feel strongly otherwise, feel free to either contribute a new CPU backend .","title":"Have you heard of LLVM/asmjit/jitasm/luajit/etc?"},{"location":"development/for_developers/#some-argument-over-an-unimportant-technical-choice","text":"In general: I don't care . That means I either really don't care and something is they way it is because that was convenient or that I don't care because it's not material to the goal of the project. There are a million important things that need to be done to get games running and going back and forth about unimportant orthogonal issues does not help. If you really do have a better way of doing something and can show it, contributions are welcome. Here's a short list of common ones: 'Why this xb stuff?' -- I like it, it helps me. If you want to manually execute commands have fun, nothing is stopping you. 'Why not just take the code from project X?' -- the point of this project is to build something different than previous emulator projects and learn while doing it. The easy way is almost never the best way and most certainly isn't as fun. 'Why not CMake?' -- I don't like CMake as it generates ugly Visual Studio projects. Premake does what I want (mostly) how I want it to.","title":"(some argument over an unimportant technical choice)"},{"location":"development/for_developers/#hey-im-going-to-go-modify-every-file-in-the-project-ok","text":"We welcome contributions, but please try to understand that we cannot accept changes that radically alter the structure or content of the code, especially if they are aesthetic and even more so if they are from someone who has not contributed before. If a pull request of this nature is denied that doesn't necessarily mean your help is not wanted, just that it may need to be more carefully applied.","title":"Hey I'm going to go modify every file in the project, ok?"},{"location":"development/instruction_tracing/","text":"","title":"Instruction Tracing"},{"location":"development/style_guide/","text":"","title":"Style Guide"},{"location":"development/console-docs/","text":"Xbox 360 Documentation In this section: Articles about the Xbox 360 hardware and system software written by Xenia contributors!","title":"Xbox 360 Documentation"},{"location":"development/console-docs/#xbox-360-documentation","text":"In this section: Articles about the Xbox 360 hardware and system software written by Xenia contributors!","title":"Xbox 360 Documentation"},{"location":"development/console-docs/cpu/","text":"CPU Documentation The JIT The JIT is the core of Xenia. It translates Xenon PowerPC code into native code runnable on the host computer. There are 3 phases to translation: 1. Translation to IR (intermediate representation) 2. IR compilation/optimization 3. Backend emission PowerPC instructions are translated to Xenia's intermediate representation format in src/xenia/cpu/ppc/ppc_emit_*.cc (e.g. processor control is done in ppc_emit_control.cc ). HIR opcodes are relatively simple opcodes such that any host can define an implementation. After the HIR is generated, it is ran through a compiler to prep it for generation. The compiler is ran in a series of passes, the order of which is defined in ppc_translator.cc . Some passes are essential to the successful generation, while others are merely for optimization purposes. Compiler passes are defined in src/xenia/cpu/compiler/passes with descriptive class names. Finally, the backend consumes the HIR and emits code that runs natively on the host. Currently, the only backend that exists is the x64 backend, with all the emission done in x64_sequences.cc . ABI Xenia guest functions are not directly callable, but rather must be called through APIs provided by Xenia. Xenia will first execute a thunk to transition the host context to a state dependent on the JIT backend, and that will call the guest code. x64 Transition thunks defined in x64_backend.cc . Registers are stored on the stack as defined by StackLayout::Thunk for later transitioning back to the host. Some registers are reserved for usage by the JIT to store temporary variables. See: X64Emitter::gpr_reg_map_ and X64Emitter::xmm_reg_map_ . Integer Registers Register Usage RAX Scratch RBX JIT temp RCX Scratch RDX Scratch RSP Stack Pointer RBP Unused RSI PowerPC Context RDI Virtual Memory Base R8-R11 Unused (parameters) R12-R15 JIT temp Floating Point Registers Register Usage XMM0-XMM5 Scratch XMM6-XMM15 JIT temp Memory Xenia defines virtual memory as a mapped range beginning at Memory::virtual_membase(), and physical memory as another mapped range from Memory::physical_membase() (usually 0x100000000 and 0x200000000, respectively). If the default bases are not available, they are shifted left 1 bit until an available range is found. The guest only has access to these ranges, nothing else. Map 0x00000000 - 0x3FFFFFFF (1024mb) - virtual 4k pages 0x40000000 - 0x7FFFFFFF (1024mb) - virtual 64k pages 0x80000000 - 0x8BFFFFFF ( 192mb) - xex 64k pages 0x8C000000 - 0x8FFFFFFF ( 64mb) - xex 64k pages (encrypted) 0x90000000 - 0x9FFFFFFF ( 256mb) - xex 4k pages 0xA0000000 - 0xBFFFFFFF ( 512mb) - physical 64k pages (overlapped) 0xC0000000 - 0xDFFFFFFF - physical 16mb pages (overlapped) 0xE0000000 - 0xFFFFFFFF - physical 4k pages (overlapped) Virtual pages are usually allocated by NtAllocateVirtualMemory, and physical pages are usually allocated by MmAllocatePhysicalMemoryEx. Virtual pages mapped to physical memory are also mapped to the physical membase, i.e. virtual 0xA0000000 == physical 0x00000000 The 0xE0000000-0xFFFFFFFF range is mapped to physical memory with a single 4 KB page offset. On Windows, memory mappings must be aligned to 64 KB, so the offset has to be added when guest addresses are converted to host addresses in the translated CPU code. This can't be faked other ways because calculations involving the offset are built into games - see the following sequence: srwi r9, r10, 20 # r9 = r10 >> 20 clrlwi r10, r10, 3 # r10 = r10 & 0x1FFFFFFF (physical address) addi r11, r9, 0x200 rlwinm r11, r11, 0,19,19 # r11 = r11 & 0x1000 add r11, r11, r10 # add 1 page to addresses > 0xE0000000 # r11 = addess passed to GPU Memory Management TODO References PowerPC The processor in the 360 is a 64-bit PowerPC chip running in 32-bit mode. Programs are still allowed to use 64-bit PowerPC instructions, and registers are 64-bit as well, but 32-bit instructions will run in 32-bit mode. The CPU is largely similar to the PPC part in the PS3, so Cell documents often line up for the core instructions. The 360 adds some additional AltiVec instructions, though, which are only documented in a few places (like the gcc source code, etc). Free60 Info Power ISA docs (aka 'PowerISA') PowerPC Programming Environments Manual (aka 'pem_64') PowerPC Vector PEM AltiVec PEM VMX128 Opcodes AltiVec Decoding x64 Intel Manuals Combined Intel Manuals Apple AltiVec/SSE Migration Guide","title":"CPU"},{"location":"development/console-docs/cpu/#cpu-documentation","text":"","title":"CPU Documentation"},{"location":"development/console-docs/cpu/#the-jit","text":"The JIT is the core of Xenia. It translates Xenon PowerPC code into native code runnable on the host computer. There are 3 phases to translation: 1. Translation to IR (intermediate representation) 2. IR compilation/optimization 3. Backend emission PowerPC instructions are translated to Xenia's intermediate representation format in src/xenia/cpu/ppc/ppc_emit_*.cc (e.g. processor control is done in ppc_emit_control.cc ). HIR opcodes are relatively simple opcodes such that any host can define an implementation. After the HIR is generated, it is ran through a compiler to prep it for generation. The compiler is ran in a series of passes, the order of which is defined in ppc_translator.cc . Some passes are essential to the successful generation, while others are merely for optimization purposes. Compiler passes are defined in src/xenia/cpu/compiler/passes with descriptive class names. Finally, the backend consumes the HIR and emits code that runs natively on the host. Currently, the only backend that exists is the x64 backend, with all the emission done in x64_sequences.cc .","title":"The JIT"},{"location":"development/console-docs/cpu/#abi","text":"Xenia guest functions are not directly callable, but rather must be called through APIs provided by Xenia. Xenia will first execute a thunk to transition the host context to a state dependent on the JIT backend, and that will call the guest code.","title":"ABI"},{"location":"development/console-docs/cpu/#x64","text":"Transition thunks defined in x64_backend.cc . Registers are stored on the stack as defined by StackLayout::Thunk for later transitioning back to the host. Some registers are reserved for usage by the JIT to store temporary variables. See: X64Emitter::gpr_reg_map_ and X64Emitter::xmm_reg_map_ .","title":"x64"},{"location":"development/console-docs/cpu/#integer-registers","text":"Register Usage RAX Scratch RBX JIT temp RCX Scratch RDX Scratch RSP Stack Pointer RBP Unused RSI PowerPC Context RDI Virtual Memory Base R8-R11 Unused (parameters) R12-R15 JIT temp","title":"Integer Registers"},{"location":"development/console-docs/cpu/#floating-point-registers","text":"Register Usage XMM0-XMM5 Scratch XMM6-XMM15 JIT temp","title":"Floating Point Registers"},{"location":"development/console-docs/cpu/#memory","text":"Xenia defines virtual memory as a mapped range beginning at Memory::virtual_membase(), and physical memory as another mapped range from Memory::physical_membase() (usually 0x100000000 and 0x200000000, respectively). If the default bases are not available, they are shifted left 1 bit until an available range is found. The guest only has access to these ranges, nothing else.","title":"Memory"},{"location":"development/console-docs/cpu/#map","text":"0x00000000 - 0x3FFFFFFF (1024mb) - virtual 4k pages 0x40000000 - 0x7FFFFFFF (1024mb) - virtual 64k pages 0x80000000 - 0x8BFFFFFF ( 192mb) - xex 64k pages 0x8C000000 - 0x8FFFFFFF ( 64mb) - xex 64k pages (encrypted) 0x90000000 - 0x9FFFFFFF ( 256mb) - xex 4k pages 0xA0000000 - 0xBFFFFFFF ( 512mb) - physical 64k pages (overlapped) 0xC0000000 - 0xDFFFFFFF - physical 16mb pages (overlapped) 0xE0000000 - 0xFFFFFFFF - physical 4k pages (overlapped) Virtual pages are usually allocated by NtAllocateVirtualMemory, and physical pages are usually allocated by MmAllocatePhysicalMemoryEx. Virtual pages mapped to physical memory are also mapped to the physical membase, i.e. virtual 0xA0000000 == physical 0x00000000 The 0xE0000000-0xFFFFFFFF range is mapped to physical memory with a single 4 KB page offset. On Windows, memory mappings must be aligned to 64 KB, so the offset has to be added when guest addresses are converted to host addresses in the translated CPU code. This can't be faked other ways because calculations involving the offset are built into games - see the following sequence: srwi r9, r10, 20 # r9 = r10 >> 20 clrlwi r10, r10, 3 # r10 = r10 & 0x1FFFFFFF (physical address) addi r11, r9, 0x200 rlwinm r11, r11, 0,19,19 # r11 = r11 & 0x1000 add r11, r11, r10 # add 1 page to addresses > 0xE0000000 # r11 = addess passed to GPU","title":"Map"},{"location":"development/console-docs/cpu/#memory-management","text":"TODO","title":"Memory Management"},{"location":"development/console-docs/cpu/#references","text":"","title":"References"},{"location":"development/console-docs/cpu/#powerpc","text":"The processor in the 360 is a 64-bit PowerPC chip running in 32-bit mode. Programs are still allowed to use 64-bit PowerPC instructions, and registers are 64-bit as well, but 32-bit instructions will run in 32-bit mode. The CPU is largely similar to the PPC part in the PS3, so Cell documents often line up for the core instructions. The 360 adds some additional AltiVec instructions, though, which are only documented in a few places (like the gcc source code, etc). Free60 Info Power ISA docs (aka 'PowerISA') PowerPC Programming Environments Manual (aka 'pem_64') PowerPC Vector PEM AltiVec PEM VMX128 Opcodes AltiVec Decoding","title":"PowerPC"},{"location":"development/console-docs/cpu/#x64_1","text":"Intel Manuals Combined Intel Manuals Apple AltiVec/SSE Migration Guide","title":"x64"},{"location":"development/console-docs/cpu_todo/","text":"CPU TODO There are many improvements that can be done under xe::cpu to improve debugging, performance (both to JIT and of generated code), and portability. Some are in various states of completion, and others are just thoughts that need more exploring. Debugging Improvements Reproducable X64 Emission It'd be useful to be able to run a PPC function through the entire pipeline and spit out x64 that is byte-for-byte identical across runs. This would allow automated verification, bulk analysis, etc. Currently X64Emitter::Emplace will relocate the x64 when placing it in memory, which will be at a different location each time. Instead it would be nice to have the xbyak calcJmpAddress that performs the relocations use the address of our choosing. Sampling Profiler Once we have stack walking it'd be nice to take something like micro-profiler and augment it to support our system. This would let us run continuous performance analysis and track hotspots in JITed code without a large performance impact. Automatically showing the top hot functions in the debugger could help track down poor translation much faster. Intel Architecture Code Analyzer Support The Intel ACA is a nifty tool that, given a kernel of x64, can detail theoretical performance characteristics on different processors down to cycle timings and potential bottlenecks on memory/execution units. It's designed to run on elf/obj/etc files however it simply looks for special markers in the code. Having something that walks the code cache and dumps a specially formatted file with the markers around basic blocks could allow running the tool in bulk, or alternatively being able to invoke it one-off by dumping a specific x64 block to disk and processing it for display when looking at the code in the debugger would be useful. I've done some early experiments with this and its possible to pass just a bin file with the markers and the x64. Function Tracing/Coverage Information function_trace_data.h contains the FunctionTraceData struct, which is currently partially populated by the x64 backend. This enables tracking of which threads a function is called on, function call count, recent callers of the function, and even instruction-level counts. This is all only partially implemented, though, and there's no tool to read it out. This would be nice to get integrated into the debugger so that it can overlay the information when viewing a function, but also useful in aggregate to find hot functions/code paths or enhance callstacks by automatically annotating thread information. Block-level Counting Currently the code assumes each instruction has a count, however this is expensive and often unneeded as it can be done on a block level and then the instruction counts can be derived from that. This can reduce the overhead (both in memory and accounting time) by an order of magnitude. On-Stack Context Inspection Currently the debugger only works with --store_all_context_values , as it can only get the values of PPC registers when they are stored to the PPC context after each instruction. As this can slow things down by ~10-20% it could be useful to be able to preserve the optimized and register-allocated HIR so that host registers holding context values can be derived on demand. Or, we could just make --store_all_context_values faster. JIT Performance Improvements Reduce HIR Size Currently there are a lot of pointers stored within Instr , Value , and related types. These are big 8B values that eat a lot of memory and really hurt the cache (especially with all the block/instruction walking done). Aligning everything to 16B values in the arena and using 16bit indices (or something) could shrink things a lot. Serialize Code Cache The x64 code cache is currently set up to use fixed memory addresses and is even represented as mapped memory. It should be fairly easy to back this with a file and have all code written to disk. Adding more metadata, or perhaps a side-car file, would allow for the code to be written to disk. On future runs the code cache could load this data (by mapping the file containing the code right into memory) and short cut JIT'ing entirely. It would be possible to use a common container format (ELF/etc), however there's elegance in not requiring any additional steps beyond the memory mapping. Such containers could be useful for running static tools against, though. Portability Improvements Emulated Opcode Layer Having a way to use emulated variants for any HIR opcode in a backend would help when writing a new backend as well as when verifying the existing backends. This may look like a C library with functions for each opcode/type pairing and utilities to call out to them. Something like the x64 backend could then call out to these with CallNativeSafe (or some faster equivalent) and something like an interpreter backend would be fairly trivial to write. X64 Backend Improvements Implement Emulated Instructions There are a ton of half-implemented HIR opcodes that call out to C++ to do their work. These are extremely expensive as they incur a full guest-to-host thunk (~hundreds of instructions!). Basically, any of the Emulate* / CallNativeSafe functions in x64_sequences.cc need to be replaced with proper AVX/AVX2 variants. Increase Register Availability Currently only a few x64 registers are usable (due to reservations by the backend or ABI conflicts). Though register pressure is surprisingly light in most cases there are pathological cases that result in a lot of spills. By freeing up some of the registers these spills could be reduced. Constant Pooling This may make sense as a compiler pass instead. Right now, particular sequences of instructions are nasty - such as anything using LoadConstantXmm to load non-zero or non-1 vec128's. Instead of doing the super fat (20-30byte!) constant loads as they are done now it may be better to keep a per-function constant table and instead use RIP-relative addressing (or something) to use the memory-form AVX instructions. For example, right now this: v82.v128 = [0,1,2,3] v83.v128 = or v81.v128, v82.128 Translates to (something like): mov([rsp+0x...], 0x00000000) mov([rsp+0x...+4], 0x00000001) mov([rsp+0x...+8], 0x00000002) mov([rsp+0x...+12], 0x00000003) vmovdqa(xmm2, [rsp+0x...]) vor(xmm2, xmm2, xmm2) Where as it could be: vor(xmm2, xmm2, [rip+0x...]) Whether the cost of doing the constant de-dupe is worth it remains to be seen. Right now it's wasting a lot of instruction cache space, increasing decode time, and potentially using a lot more memory bandwidth. Optimization Improvements Speed Up RegisterAllocationPass Currently the slowest pass, this could be improved by requiring less use tracking or perhaps maintaining the use tracking in other passes. A faster SortUsageList (radix or something fancy?) may be helpful as well. More Opcodes in ConstantPropagationPass There's a few HIR opcodes with no handling, and others with minimal handling. It'd be nice to know what paths need improvement and add them, as any work here makes things free later on. Cross-Block ConstantPropagationPass Constant propagation currently only occurs within a single block. This makes it difficult to optimize common PPC patterns like loading the constants 0 or 1 into a register before a loop and other loads of expensive altivec values. Either ControlFlowAnalysisPass or DataFlowAnalysisPass could be piggy-backed to track constant load_context/store_context's across block bounds and propagate the values. This is simpler than dynamic values as no phi functions or anything fancy needs to happen. Add TypePropagationPass There are many extensions/truncations in generated code right now due to various load/stores of varying widths. Being able to find and short- circuit the conversions early on would make following passes cleaner and faster as they'd have to trace through fewer value definitions and there'd be less extraneous movs in the final code. Example (after ContextPromotion): v82.i32 = truncate v81.i64 v83.i32 = and v82.i32, 3F v85.i64 = zero_extend v84.i32 Becomes (after DCE/etc): v85.i64 = and v81.i64, 3F Enhance MemorySequenceCombinationPass with Extend/Truncate Currently this pass will look for byte_swap and merge that into loads/stores. This allows for better final codegen at the cost of making optimization more difficult, so it only happens at the end of the process. There's currently TODOs in there for adding extend/truncate support, which will extend what it does with swaps to also merge the sign_extend/zero_extend/truncate into the matching load/store. This allows for the x64 backend to generate the proper mov's that do these operations without requiring additional steps. Note that if we had a LIR and a peephole optimizer this would be better done there. Load with swap and extend: v1.i32 = load v0 v2.i32 = byte_swap v1.i32 v3.i64 = zero_extend v2.i32 Becomes: v1.i64 = load_convert v0, [swap|i32->i64,zero] Store with truncate and swap: v1.i64 = ... v2.i32 = truncate v1.i64 v3.i32 = byte_swap v2.i32 store v0, v3.i32 Becomes: store_convert v0, v1.i64, [swap|i64->i32,trunc] Add DeadStoreEliminationPass Generic DSE pass, removing all redundant stores. ContextPromotion may be able to take care of most of these, as the input assembly is generally pretty optimized already. This pass would mainly be looking for introduced stores, such as those from comparisons. Currently ControlFlowAnalysisPass will annotate blocks with incoming/outgoing edges as well as dominators, and that could be used to check whether stores into the context are used in their destination block or instead overwritten (currently they almost never are). If this pass was able to remove a good number of the stores then the comparisons would also be removed with dead code elimination and dramatically reduce branch overhead. Example: <block0>: v0 = compare_ult ... (later removed by DCE) v1 = compare_ugt ... (later removed by DCE) v2 = compare_eq ... store_context +300, v0 <-- removed store_context +301, v1 <-- removed store_context +302, v2 <-- removed branch_true v1, ... <block1>: v3 = compare_ult ... v4 = compare_ugt ... v5 = compare_eq ... store_context +300, v3 <-- these may be required if at end of function store_context +301, v4 or before a call store_context +302, v5 branch_true v5, ... Add X64CanonicalizationPass For various opcodes add copies/commute the arguments to match x64 operand semantics. This makes code generation easier and if done before register allocation can prevent a lot of extra shuffling in the emitted code. Example: <block0>: v0 = ... v1 = ... v2 = add v0, v1 <-- v1 now unused Becomes: v0 = ... v1 = ... v1 = add v1, v0 <-- src1 = dest/src, so reuse for both by commuting and setting dest = src1 Add MergeLocalSlotsPass As the RegisterAllocationPass runs it generates load_local/store_local as it spills. Currently each set of locals is unique to each block, which in very large functions can result in a lot of locals that are only used briefly. It may be useful to use the results of the ControlFlowAnalysisPass to track local liveness and merge the slots so they are reused when they cannot possibly be live at the same time. This saves stack space and potentially improves cache behavior.","title":"CPU To-Do"},{"location":"development/console-docs/cpu_todo/#cpu-todo","text":"There are many improvements that can be done under xe::cpu to improve debugging, performance (both to JIT and of generated code), and portability. Some are in various states of completion, and others are just thoughts that need more exploring.","title":"CPU TODO"},{"location":"development/console-docs/cpu_todo/#debugging-improvements","text":"","title":"Debugging Improvements"},{"location":"development/console-docs/cpu_todo/#reproducable-x64-emission","text":"It'd be useful to be able to run a PPC function through the entire pipeline and spit out x64 that is byte-for-byte identical across runs. This would allow automated verification, bulk analysis, etc. Currently X64Emitter::Emplace will relocate the x64 when placing it in memory, which will be at a different location each time. Instead it would be nice to have the xbyak calcJmpAddress that performs the relocations use the address of our choosing.","title":"Reproducable X64 Emission"},{"location":"development/console-docs/cpu_todo/#sampling-profiler","text":"Once we have stack walking it'd be nice to take something like micro-profiler and augment it to support our system. This would let us run continuous performance analysis and track hotspots in JITed code without a large performance impact. Automatically showing the top hot functions in the debugger could help track down poor translation much faster.","title":"Sampling Profiler"},{"location":"development/console-docs/cpu_todo/#intel-architecture-code-analyzer-support","text":"The Intel ACA is a nifty tool that, given a kernel of x64, can detail theoretical performance characteristics on different processors down to cycle timings and potential bottlenecks on memory/execution units. It's designed to run on elf/obj/etc files however it simply looks for special markers in the code. Having something that walks the code cache and dumps a specially formatted file with the markers around basic blocks could allow running the tool in bulk, or alternatively being able to invoke it one-off by dumping a specific x64 block to disk and processing it for display when looking at the code in the debugger would be useful. I've done some early experiments with this and its possible to pass just a bin file with the markers and the x64.","title":"Intel Architecture Code Analyzer Support"},{"location":"development/console-docs/cpu_todo/#function-tracingcoverage-information","text":"function_trace_data.h contains the FunctionTraceData struct, which is currently partially populated by the x64 backend. This enables tracking of which threads a function is called on, function call count, recent callers of the function, and even instruction-level counts. This is all only partially implemented, though, and there's no tool to read it out. This would be nice to get integrated into the debugger so that it can overlay the information when viewing a function, but also useful in aggregate to find hot functions/code paths or enhance callstacks by automatically annotating thread information.","title":"Function Tracing/Coverage Information"},{"location":"development/console-docs/cpu_todo/#block-level-counting","text":"Currently the code assumes each instruction has a count, however this is expensive and often unneeded as it can be done on a block level and then the instruction counts can be derived from that. This can reduce the overhead (both in memory and accounting time) by an order of magnitude.","title":"Block-level Counting"},{"location":"development/console-docs/cpu_todo/#on-stack-context-inspection","text":"Currently the debugger only works with --store_all_context_values , as it can only get the values of PPC registers when they are stored to the PPC context after each instruction. As this can slow things down by ~10-20% it could be useful to be able to preserve the optimized and register-allocated HIR so that host registers holding context values can be derived on demand. Or, we could just make --store_all_context_values faster.","title":"On-Stack Context Inspection"},{"location":"development/console-docs/cpu_todo/#jit-performance-improvements","text":"","title":"JIT Performance Improvements"},{"location":"development/console-docs/cpu_todo/#reduce-hir-size","text":"Currently there are a lot of pointers stored within Instr , Value , and related types. These are big 8B values that eat a lot of memory and really hurt the cache (especially with all the block/instruction walking done). Aligning everything to 16B values in the arena and using 16bit indices (or something) could shrink things a lot.","title":"Reduce HIR Size"},{"location":"development/console-docs/cpu_todo/#serialize-code-cache","text":"The x64 code cache is currently set up to use fixed memory addresses and is even represented as mapped memory. It should be fairly easy to back this with a file and have all code written to disk. Adding more metadata, or perhaps a side-car file, would allow for the code to be written to disk. On future runs the code cache could load this data (by mapping the file containing the code right into memory) and short cut JIT'ing entirely. It would be possible to use a common container format (ELF/etc), however there's elegance in not requiring any additional steps beyond the memory mapping. Such containers could be useful for running static tools against, though.","title":"Serialize Code Cache"},{"location":"development/console-docs/cpu_todo/#portability-improvements","text":"","title":"Portability Improvements"},{"location":"development/console-docs/cpu_todo/#emulated-opcode-layer","text":"Having a way to use emulated variants for any HIR opcode in a backend would help when writing a new backend as well as when verifying the existing backends. This may look like a C library with functions for each opcode/type pairing and utilities to call out to them. Something like the x64 backend could then call out to these with CallNativeSafe (or some faster equivalent) and something like an interpreter backend would be fairly trivial to write.","title":"Emulated Opcode Layer"},{"location":"development/console-docs/cpu_todo/#x64-backend-improvements","text":"","title":"X64 Backend Improvements"},{"location":"development/console-docs/cpu_todo/#implement-emulated-instructions","text":"There are a ton of half-implemented HIR opcodes that call out to C++ to do their work. These are extremely expensive as they incur a full guest-to-host thunk (~hundreds of instructions!). Basically, any of the Emulate* / CallNativeSafe functions in x64_sequences.cc need to be replaced with proper AVX/AVX2 variants.","title":"Implement Emulated Instructions"},{"location":"development/console-docs/cpu_todo/#increase-register-availability","text":"Currently only a few x64 registers are usable (due to reservations by the backend or ABI conflicts). Though register pressure is surprisingly light in most cases there are pathological cases that result in a lot of spills. By freeing up some of the registers these spills could be reduced.","title":"Increase Register Availability"},{"location":"development/console-docs/cpu_todo/#constant-pooling","text":"This may make sense as a compiler pass instead. Right now, particular sequences of instructions are nasty - such as anything using LoadConstantXmm to load non-zero or non-1 vec128's. Instead of doing the super fat (20-30byte!) constant loads as they are done now it may be better to keep a per-function constant table and instead use RIP-relative addressing (or something) to use the memory-form AVX instructions. For example, right now this: v82.v128 = [0,1,2,3] v83.v128 = or v81.v128, v82.128 Translates to (something like): mov([rsp+0x...], 0x00000000) mov([rsp+0x...+4], 0x00000001) mov([rsp+0x...+8], 0x00000002) mov([rsp+0x...+12], 0x00000003) vmovdqa(xmm2, [rsp+0x...]) vor(xmm2, xmm2, xmm2) Where as it could be: vor(xmm2, xmm2, [rip+0x...]) Whether the cost of doing the constant de-dupe is worth it remains to be seen. Right now it's wasting a lot of instruction cache space, increasing decode time, and potentially using a lot more memory bandwidth.","title":"Constant Pooling"},{"location":"development/console-docs/cpu_todo/#optimization-improvements","text":"","title":"Optimization Improvements"},{"location":"development/console-docs/cpu_todo/#speed-up-registerallocationpass","text":"Currently the slowest pass, this could be improved by requiring less use tracking or perhaps maintaining the use tracking in other passes. A faster SortUsageList (radix or something fancy?) may be helpful as well.","title":"Speed Up RegisterAllocationPass"},{"location":"development/console-docs/cpu_todo/#more-opcodes-in-constantpropagationpass","text":"There's a few HIR opcodes with no handling, and others with minimal handling. It'd be nice to know what paths need improvement and add them, as any work here makes things free later on.","title":"More Opcodes in ConstantPropagationPass"},{"location":"development/console-docs/cpu_todo/#cross-block-constantpropagationpass","text":"Constant propagation currently only occurs within a single block. This makes it difficult to optimize common PPC patterns like loading the constants 0 or 1 into a register before a loop and other loads of expensive altivec values. Either ControlFlowAnalysisPass or DataFlowAnalysisPass could be piggy-backed to track constant load_context/store_context's across block bounds and propagate the values. This is simpler than dynamic values as no phi functions or anything fancy needs to happen.","title":"Cross-Block ConstantPropagationPass"},{"location":"development/console-docs/cpu_todo/#add-typepropagationpass","text":"There are many extensions/truncations in generated code right now due to various load/stores of varying widths. Being able to find and short- circuit the conversions early on would make following passes cleaner and faster as they'd have to trace through fewer value definitions and there'd be less extraneous movs in the final code. Example (after ContextPromotion): v82.i32 = truncate v81.i64 v83.i32 = and v82.i32, 3F v85.i64 = zero_extend v84.i32 Becomes (after DCE/etc): v85.i64 = and v81.i64, 3F","title":"Add TypePropagationPass"},{"location":"development/console-docs/cpu_todo/#enhance-memorysequencecombinationpass-with-extendtruncate","text":"Currently this pass will look for byte_swap and merge that into loads/stores. This allows for better final codegen at the cost of making optimization more difficult, so it only happens at the end of the process. There's currently TODOs in there for adding extend/truncate support, which will extend what it does with swaps to also merge the sign_extend/zero_extend/truncate into the matching load/store. This allows for the x64 backend to generate the proper mov's that do these operations without requiring additional steps. Note that if we had a LIR and a peephole optimizer this would be better done there. Load with swap and extend: v1.i32 = load v0 v2.i32 = byte_swap v1.i32 v3.i64 = zero_extend v2.i32 Becomes: v1.i64 = load_convert v0, [swap|i32->i64,zero] Store with truncate and swap: v1.i64 = ... v2.i32 = truncate v1.i64 v3.i32 = byte_swap v2.i32 store v0, v3.i32 Becomes: store_convert v0, v1.i64, [swap|i64->i32,trunc]","title":"Enhance MemorySequenceCombinationPass with Extend/Truncate"},{"location":"development/console-docs/cpu_todo/#add-deadstoreeliminationpass","text":"Generic DSE pass, removing all redundant stores. ContextPromotion may be able to take care of most of these, as the input assembly is generally pretty optimized already. This pass would mainly be looking for introduced stores, such as those from comparisons. Currently ControlFlowAnalysisPass will annotate blocks with incoming/outgoing edges as well as dominators, and that could be used to check whether stores into the context are used in their destination block or instead overwritten (currently they almost never are). If this pass was able to remove a good number of the stores then the comparisons would also be removed with dead code elimination and dramatically reduce branch overhead. Example: <block0>: v0 = compare_ult ... (later removed by DCE) v1 = compare_ugt ... (later removed by DCE) v2 = compare_eq ... store_context +300, v0 <-- removed store_context +301, v1 <-- removed store_context +302, v2 <-- removed branch_true v1, ... <block1>: v3 = compare_ult ... v4 = compare_ugt ... v5 = compare_eq ... store_context +300, v3 <-- these may be required if at end of function store_context +301, v4 or before a call store_context +302, v5 branch_true v5, ...","title":"Add DeadStoreEliminationPass"},{"location":"development/console-docs/cpu_todo/#add-x64canonicalizationpass","text":"For various opcodes add copies/commute the arguments to match x64 operand semantics. This makes code generation easier and if done before register allocation can prevent a lot of extra shuffling in the emitted code. Example: <block0>: v0 = ... v1 = ... v2 = add v0, v1 <-- v1 now unused Becomes: v0 = ... v1 = ... v1 = add v1, v0 <-- src1 = dest/src, so reuse for both by commuting and setting dest = src1","title":"Add X64CanonicalizationPass"},{"location":"development/console-docs/cpu_todo/#add-mergelocalslotspass","text":"As the RegisterAllocationPass runs it generates load_local/store_local as it spills. Currently each set of locals is unique to each block, which in very large functions can result in a lot of locals that are only used briefly. It may be useful to use the results of the ControlFlowAnalysisPass to track local liveness and merge the slots so they are reused when they cannot possibly be live at the same time. This saves stack space and potentially improves cache behavior.","title":"Add MergeLocalSlotsPass"},{"location":"development/console-docs/gpu/","text":"GPU Documentation The Xenos Chip The Xenos is a graphics chip designed by AMD based off of the R5xx architecture. Command Processing The Xenos runs commands supplied to it directly by the DirectX bare-bones driver via a ringbuffer located in system memory. The bulk of the command processing code is located at src/xenia/gpu/command_processor.cc EDRAM The Xenos uses special high-speed memory located on the same die as the chip to store framebuffers/render targets. TODO: More documentation Options General See the top of gpu_flags.cc . --vsync=false will attempt to render the game as fast as possible instead of waiting for a fixed 60hz timer. Vulkan See the top of vulkan_gpu_flags.cc . vulkan_dump_disasm=true \"Dump shader disassembly. NVIDIA only supported.\" Tools Shaders Shader Dumps Adding --dump_shaders=path/ will write all translated shaders to the given path with names based on input hash (so they'll be stable across runs). Binaries containing the original microcode will be placed side-by-side with the dumped output to make it easy to pipe to xe-gpu-shader-compiler . xe-gpu-shader-compiler A standalone shader compiler exists to allow for quick shader translation testing. You can pass a binary ucode shader in and get either disassembled ucode or translated source out. This is best used through the Shader Playground tool. xe-gpu-shader-compiler \\ --shader_input=input_file.bin.vs (or .fs) --shader_output=output_file.txt --shader_output_type=ucode (or spirvtext) Shader Playground Built separately (for now) under tools/shader-playground/ is a GUI for interactive shader assembly, disassembly, validation, and translation. Entering shader microcode on the left will invoke the XNA Game Studio D3D compiler to translate the ucode to binary. The D3D compiler is then used to disassemble the binary and display the optimized form. If xe-gpu-shader-compiler has been built the ucode will be passed to that for disassembly and that will then be passed through D3D compiler. If the output of D3D compiler on the xenia disassembly doesn't match the original D3D compiler output the box will turn red, indicating that the disassembly is broken. Finally, the right most box will show the translated shader in the desired format. For more information and setup instructions see tools/shader-playground/README.md . xe-gpu-trace-viewer To quickly iterate on graphical issues, xenia can dump frames (or sequences of frames) while running that can be opened and inspected in a separate app. The basic workflow is: Capture the frame in game (using F4) or a stream of frames. Add the file path to the xe-gpu-trace-viewer Debugging command line in Visual Studio. Launch xe-gpu-trace-viewer. Poke around, find issues, etc. Modify code. Build and relaunch. Goto 4. Capturing Frames First, specify a path to capture traces to with --trace_gpu_prefix=path/file_prefix_ . All files will have a randomish name based on that. When running xenia.exe you can hit F4 at any time to capture the next frame the game tries to draw (up until a VdSwap call). The file can be used immediately. Capturing Sequences Passing --trace_gpu_stream will write all frames rendered to a file, allowing you to seek through them in the trace viewer. These files will get large. References Command Buffer/Registers Registers documented at register_table.inc . PM4 commands documented at xenos.h . Performance Counters that may be read back by D3D They are 64-bit values and have a high and low 32-bit register as well as a SELECT register each: CP_PERFCOUNTER0 RBBM_PERFCOUNTER0 RBBM_PERFCOUNTER1 SQ_PERFCOUNTER0 SQ_PERFCOUNTER1 SQ_PERFCOUNTER2 SQ_PERFCOUNTER3 VGT_PERFCOUNTER0 VGT_PERFCOUNTER1 VGT_PERFCOUNTER2 VGT_PERFCOUNTER3 VC_PERFCOUNTER0 VC_PERFCOUNTER1 VC_PERFCOUNTER2 VC_PERFCOUNTER3 PA_SU_PERFCOUNTER0 PA_SU_PERFCOUNTER1 PA_SU_PERFCOUNTER2 PA_SU_PERFCOUNTER3 PA_SC_PERFCOUNTER0 PA_SC_PERFCOUNTER1 PA_SC_PERFCOUNTER2 PA_SC_PERFCOUNTER3 HZ_PERFCOUNTER0 HZ_PERFCOUNTER1 TCR_PERFCOUNTER0 TCR_PERFCOUNTER1 TCM_PERFCOUNTER0 TCM_PERFCOUNTER1 TCF_PERFCOUNTER0 TCF_PERFCOUNTER1 TCF_PERFCOUNTER2 TCF_PERFCOUNTER3 TCF_PERFCOUNTER4 TCF_PERFCOUNTER5 TCF_PERFCOUNTER6 TCF_PERFCOUNTER7 TCF_PERFCOUNTER8 TCF_PERFCOUNTER9 TCF_PERFCOUNTER10 TCF_PERFCOUNTER11 TP0_PERFCOUNTER0 TP0_PERFCOUNTER1 TP1_PERFCOUNTER0 TP1_PERFCOUNTER1 TP2_PERFCOUNTER0 TP2_PERFCOUNTER1 TP3_PERFCOUNTER0 TP3_PERFCOUNTER1 SX_PERFCOUNTER0 BC_PERFCOUNTER0 BC_PERFCOUNTER1 BC_PERFCOUNTER2 BC_PERFCOUNTER3 MC0_PERFCOUNTER0 MC1_PERFCOUNTER0 MH_PERFCOUNTER0 MH_PERFCOUNTER1 MH_PERFCOUNTER2 BIF_PERFCOUNTER0 Shaders LLVM R600 Tables ** The opcode formats don't match, but the name->psuedo code is correct. xemit","title":"GPU"},{"location":"development/console-docs/gpu/#gpu-documentation","text":"","title":"GPU Documentation"},{"location":"development/console-docs/gpu/#the-xenos-chip","text":"The Xenos is a graphics chip designed by AMD based off of the R5xx architecture.","title":"The Xenos Chip"},{"location":"development/console-docs/gpu/#command-processing","text":"The Xenos runs commands supplied to it directly by the DirectX bare-bones driver via a ringbuffer located in system memory. The bulk of the command processing code is located at src/xenia/gpu/command_processor.cc","title":"Command Processing"},{"location":"development/console-docs/gpu/#edram","text":"The Xenos uses special high-speed memory located on the same die as the chip to store framebuffers/render targets. TODO: More documentation","title":"EDRAM"},{"location":"development/console-docs/gpu/#options","text":"","title":"Options"},{"location":"development/console-docs/gpu/#general","text":"See the top of gpu_flags.cc . --vsync=false will attempt to render the game as fast as possible instead of waiting for a fixed 60hz timer.","title":"General"},{"location":"development/console-docs/gpu/#vulkan","text":"See the top of vulkan_gpu_flags.cc . vulkan_dump_disasm=true \"Dump shader disassembly. NVIDIA only supported.\"","title":"Vulkan"},{"location":"development/console-docs/gpu/#tools","text":"","title":"Tools"},{"location":"development/console-docs/gpu/#shaders","text":"","title":"Shaders"},{"location":"development/console-docs/gpu/#shader-dumps","text":"Adding --dump_shaders=path/ will write all translated shaders to the given path with names based on input hash (so they'll be stable across runs). Binaries containing the original microcode will be placed side-by-side with the dumped output to make it easy to pipe to xe-gpu-shader-compiler .","title":"Shader Dumps"},{"location":"development/console-docs/gpu/#xe-gpu-shader-compiler","text":"A standalone shader compiler exists to allow for quick shader translation testing. You can pass a binary ucode shader in and get either disassembled ucode or translated source out. This is best used through the Shader Playground tool. xe-gpu-shader-compiler \\ --shader_input=input_file.bin.vs (or .fs) --shader_output=output_file.txt --shader_output_type=ucode (or spirvtext)","title":"xe-gpu-shader-compiler"},{"location":"development/console-docs/gpu/#shader-playground","text":"Built separately (for now) under tools/shader-playground/ is a GUI for interactive shader assembly, disassembly, validation, and translation. Entering shader microcode on the left will invoke the XNA Game Studio D3D compiler to translate the ucode to binary. The D3D compiler is then used to disassemble the binary and display the optimized form. If xe-gpu-shader-compiler has been built the ucode will be passed to that for disassembly and that will then be passed through D3D compiler. If the output of D3D compiler on the xenia disassembly doesn't match the original D3D compiler output the box will turn red, indicating that the disassembly is broken. Finally, the right most box will show the translated shader in the desired format. For more information and setup instructions see tools/shader-playground/README.md .","title":"Shader Playground"},{"location":"development/console-docs/gpu/#xe-gpu-trace-viewer","text":"To quickly iterate on graphical issues, xenia can dump frames (or sequences of frames) while running that can be opened and inspected in a separate app. The basic workflow is: Capture the frame in game (using F4) or a stream of frames. Add the file path to the xe-gpu-trace-viewer Debugging command line in Visual Studio. Launch xe-gpu-trace-viewer. Poke around, find issues, etc. Modify code. Build and relaunch. Goto 4.","title":"xe-gpu-trace-viewer"},{"location":"development/console-docs/gpu/#capturing-frames","text":"First, specify a path to capture traces to with --trace_gpu_prefix=path/file_prefix_ . All files will have a randomish name based on that. When running xenia.exe you can hit F4 at any time to capture the next frame the game tries to draw (up until a VdSwap call). The file can be used immediately.","title":"Capturing Frames"},{"location":"development/console-docs/gpu/#capturing-sequences","text":"Passing --trace_gpu_stream will write all frames rendered to a file, allowing you to seek through them in the trace viewer. These files will get large.","title":"Capturing Sequences"},{"location":"development/console-docs/gpu/#references","text":"","title":"References"},{"location":"development/console-docs/gpu/#command-bufferregisters","text":"Registers documented at register_table.inc . PM4 commands documented at xenos.h .","title":"Command Buffer/Registers"},{"location":"development/console-docs/gpu/#performance-counters-that-may-be-read-back-by-d3d","text":"They are 64-bit values and have a high and low 32-bit register as well as a SELECT register each: CP_PERFCOUNTER0 RBBM_PERFCOUNTER0 RBBM_PERFCOUNTER1 SQ_PERFCOUNTER0 SQ_PERFCOUNTER1 SQ_PERFCOUNTER2 SQ_PERFCOUNTER3 VGT_PERFCOUNTER0 VGT_PERFCOUNTER1 VGT_PERFCOUNTER2 VGT_PERFCOUNTER3 VC_PERFCOUNTER0 VC_PERFCOUNTER1 VC_PERFCOUNTER2 VC_PERFCOUNTER3 PA_SU_PERFCOUNTER0 PA_SU_PERFCOUNTER1 PA_SU_PERFCOUNTER2 PA_SU_PERFCOUNTER3 PA_SC_PERFCOUNTER0 PA_SC_PERFCOUNTER1 PA_SC_PERFCOUNTER2 PA_SC_PERFCOUNTER3 HZ_PERFCOUNTER0 HZ_PERFCOUNTER1 TCR_PERFCOUNTER0 TCR_PERFCOUNTER1 TCM_PERFCOUNTER0 TCM_PERFCOUNTER1 TCF_PERFCOUNTER0 TCF_PERFCOUNTER1 TCF_PERFCOUNTER2 TCF_PERFCOUNTER3 TCF_PERFCOUNTER4 TCF_PERFCOUNTER5 TCF_PERFCOUNTER6 TCF_PERFCOUNTER7 TCF_PERFCOUNTER8 TCF_PERFCOUNTER9 TCF_PERFCOUNTER10 TCF_PERFCOUNTER11 TP0_PERFCOUNTER0 TP0_PERFCOUNTER1 TP1_PERFCOUNTER0 TP1_PERFCOUNTER1 TP2_PERFCOUNTER0 TP2_PERFCOUNTER1 TP3_PERFCOUNTER0 TP3_PERFCOUNTER1 SX_PERFCOUNTER0 BC_PERFCOUNTER0 BC_PERFCOUNTER1 BC_PERFCOUNTER2 BC_PERFCOUNTER3 MC0_PERFCOUNTER0 MC1_PERFCOUNTER0 MH_PERFCOUNTER0 MH_PERFCOUNTER1 MH_PERFCOUNTER2 BIF_PERFCOUNTER0","title":"Performance Counters that may be read back by D3D"},{"location":"development/console-docs/gpu/#shaders_1","text":"LLVM R600 Tables ** The opcode formats don't match, but the name->psuedo code is correct. xemit","title":"Shaders"},{"location":"development/console-docs/kernel/","text":"Kernel Documentation Kernel shims Xenia implements all kernel APIs as native functions under the host. When a module is loaded, the loader will find all kernel imports, put a syscall in their place, then lookup a kernel export and link it to each import. The JIT will generate a sequence of instructions to call into Xenia's export if it encounters a syscall. Currently, there are two ways an export can be defined - for example : * SHIM_CALL XAudioGetSpeakerConfig_shim(PPCContext* ppc_context, KernelState* kernel_state) * dword_result_t XAudioGetSpeakerConfig(lpdword_t config_ptr) The SHIM_CALL convention is deprecated, but allows a closer look at the internals of how calls are done. ppc_context is the guest PowerPC context, which holds all guest registers. Function parameters are fetched from r3...r10 ( SHIM_GET_ARG_32 ), and additional parameters are loaded from the stack. The return value (if there is one) is stored in r3 ( SHIM_SET_RETURN_32 ). Details on how calls transition from guest -> host can be found in the cpu documentation . The newer convention does the same, but uses templates to automate the process of loading arguments and setting a return value. Kernel Modules Xenia has an implementation of two xbox kernel modules, xboxkrnl.exe and xam.xex xboxkrnl.exe - Xbox kernel Defined under src/xenia/kernel/xboxkrnl. This is a slightly modified version of the NT kernel. Most of the APIs are equivalent to ones you'd find on MSDN or other online sources. Source files are organized into groups of APIs. xam.xex - Xbox Auxiliary Methods Defined under src/xenia/kernel/xam. This module implements functionality specific to the Xbox.","title":"Kernel"},{"location":"development/console-docs/kernel/#kernel-documentation","text":"","title":"Kernel Documentation"},{"location":"development/console-docs/kernel/#kernel-shims","text":"Xenia implements all kernel APIs as native functions under the host. When a module is loaded, the loader will find all kernel imports, put a syscall in their place, then lookup a kernel export and link it to each import. The JIT will generate a sequence of instructions to call into Xenia's export if it encounters a syscall. Currently, there are two ways an export can be defined - for example : * SHIM_CALL XAudioGetSpeakerConfig_shim(PPCContext* ppc_context, KernelState* kernel_state) * dword_result_t XAudioGetSpeakerConfig(lpdword_t config_ptr) The SHIM_CALL convention is deprecated, but allows a closer look at the internals of how calls are done. ppc_context is the guest PowerPC context, which holds all guest registers. Function parameters are fetched from r3...r10 ( SHIM_GET_ARG_32 ), and additional parameters are loaded from the stack. The return value (if there is one) is stored in r3 ( SHIM_SET_RETURN_32 ). Details on how calls transition from guest -> host can be found in the cpu documentation . The newer convention does the same, but uses templates to automate the process of loading arguments and setting a return value.","title":"Kernel shims"},{"location":"development/console-docs/kernel/#kernel-modules","text":"Xenia has an implementation of two xbox kernel modules, xboxkrnl.exe and xam.xex","title":"Kernel Modules"},{"location":"development/console-docs/kernel/#xboxkrnlexe-xbox-kernel","text":"Defined under src/xenia/kernel/xboxkrnl. This is a slightly modified version of the NT kernel. Most of the APIs are equivalent to ones you'd find on MSDN or other online sources. Source files are organized into groups of APIs.","title":"xboxkrnl.exe - Xbox kernel"},{"location":"development/console-docs/kernel/#xamxex-xbox-auxiliary-methods","text":"Defined under src/xenia/kernel/xam. This module implements functionality specific to the Xbox.","title":"xam.xex - Xbox Auxiliary Methods"},{"location":"development/references/","text":"Developer References This section of the wiki provides links and downloads for useful references about the Xbox 360 and Xenia's target platforms. Links Xbox 360 References Target References","title":"Developer References"},{"location":"development/references/#developer-references","text":"This section of the wiki provides links and downloads for useful references about the Xbox 360 and Xenia's target platforms. Links Xbox 360 References Target References","title":"Developer References"},{"location":"development/references/console/","text":"Developer References In this section, you can find references that may help you as a developer of Xenia, or as a maintainer of the wiki. Another great resource you may consider contributing to is the Free60 Wiki . If you have some information about the Xbox 360 you would like to write an article on, please consider sharing it there, and linking it here. If you find a relevant (public) PDF file, you can add it to the repo for archival purposes and link it here. See the console-refs/documents folder on GitHub . Tools Reverse Engineering Name + Link Description + Author Ghidra Open source tool for decompiling binary files developed by the NSA XexLoaderWV Plugin by WarrantyVoider for Ghidra that allows XEX2 executables to be decompiled IDA Pro Premium closed source tool for decompiling binary files IDAXex Plugin developed by emoose for IDA Pro that allows decompiling XEX binaries of multiple formats Xbox 360 Hardware CPU Name + Link Description + Author PowerPC Core Instructions Core PowerPC CPU instruction set by IBM PowerPC AltiVec Instructions AltiVec Instruction set by Motorola GPU Name + Link Description + Author AMD R600 Instruction Set Architecture Official AMD R600 ISA documentation Xbox 360 Software","title":"Xbox 360"},{"location":"development/references/console/#developer-references","text":"In this section, you can find references that may help you as a developer of Xenia, or as a maintainer of the wiki. Another great resource you may consider contributing to is the Free60 Wiki . If you have some information about the Xbox 360 you would like to write an article on, please consider sharing it there, and linking it here. If you find a relevant (public) PDF file, you can add it to the repo for archival purposes and link it here. See the console-refs/documents folder on GitHub .","title":"Developer References"},{"location":"development/references/console/#tools","text":"","title":"Tools"},{"location":"development/references/console/#reverse-engineering","text":"Name + Link Description + Author Ghidra Open source tool for decompiling binary files developed by the NSA XexLoaderWV Plugin by WarrantyVoider for Ghidra that allows XEX2 executables to be decompiled IDA Pro Premium closed source tool for decompiling binary files IDAXex Plugin developed by emoose for IDA Pro that allows decompiling XEX binaries of multiple formats","title":"Reverse Engineering"},{"location":"development/references/console/#xbox-360-hardware","text":"CPU Name + Link Description + Author PowerPC Core Instructions Core PowerPC CPU instruction set by IBM PowerPC AltiVec Instructions AltiVec Instruction set by Motorola GPU Name + Link Description + Author AMD R600 Instruction Set Architecture Official AMD R600 ISA documentation","title":"Xbox 360 Hardware"},{"location":"development/references/console/#xbox-360-software","text":"","title":"Xbox 360 Software"},{"location":"development/references/target/","text":"Target References In this section you can find references about target hardware that may be useful for developers. Targets Windows Linux Android","title":"Target References"},{"location":"development/references/target/#target-references","text":"In this section you can find references about target hardware that may be useful for developers. Targets Windows Linux Android","title":"Target References"},{"location":"development/references/target/android/","text":"Android Tools Title + Link Description + Author Android Studio Google's official Android SDK for Windows, Mac, Linux, and ChromeOS. Snapdragon Profiler Qualcomm tool that allows developers to analyze CPU, GPU, DSP, memory, power, thermal, and network data. Adreno GPU SDK Qualcomm SDK for development on Adreno GPU platforms. Hardware Docs Title + Link Description + Author VK_QCOM_render_pass_transform_extension Qualcomm Vulkan vendor extension developer guide. Snapdragon OpenCL Programming and Optimization Guide Qualcomm developer guide for general programming and optimization on the Snapdragon 420 using OpenCL. generated by pstoedit version:3.44 from NVBadge_2D.eps Tegra X1 Whitepaper Official overview of the Tegra X1 SOC by NVIDIA. Software Docs Title + Link Description + Author generated by pstoedit version:3.44 from NVBadge_2D.eps Tegra Khronos SDK Documentation Official documentation of the NVIDIA Khronos Apps SDK including installation instructions.","title":"Android"},{"location":"development/references/target/android/#android","text":"","title":"Android"},{"location":"development/references/target/android/#tools","text":"Title + Link Description + Author Android Studio Google's official Android SDK for Windows, Mac, Linux, and ChromeOS. Snapdragon Profiler Qualcomm tool that allows developers to analyze CPU, GPU, DSP, memory, power, thermal, and network data. Adreno GPU SDK Qualcomm SDK for development on Adreno GPU platforms.","title":"Tools"},{"location":"development/references/target/android/#hardware-docs","text":"Title + Link Description + Author VK_QCOM_render_pass_transform_extension Qualcomm Vulkan vendor extension developer guide. Snapdragon OpenCL Programming and Optimization Guide Qualcomm developer guide for general programming and optimization on the Snapdragon 420 using OpenCL. generated by pstoedit version:3.44 from NVBadge_2D.eps Tegra X1 Whitepaper Official overview of the Tegra X1 SOC by NVIDIA.","title":"Hardware Docs"},{"location":"development/references/target/android/#software-docs","text":"Title + Link Description + Author generated by pstoedit version:3.44 from NVBadge_2D.eps Tegra Khronos SDK Documentation Official documentation of the NVIDIA Khronos Apps SDK including installation instructions.","title":"Software Docs"},{"location":"faq/","text":"Frequently Asked Questions How do I use Xenia? Refer to the Quickstart page . What are Xenia's system requirements? See the Quickstart page How do I fix the VCRUNTIME error? Refer to the Quickstart page . Why do I get an error saying \"Your CPU does not support AVX\"? Your CPU doesn't meet the minimum requirements. See the Quickstart page How do I dump games? See the guide in Quickstart . How do I improve performance? Upgrade your PC or wait for optimizations. Does Xenia support OpenGL/Direct3D11? No. (see the system requirements ) Why is the audio delayed? Audio is one of the least worked on things in Xenia. There is no fix. How do I fix \"Graphics device lost (probably due to an internal error\"? You can't. Can you add support for Windows Me? How about my Pentium II? Support for older operating systems and processors will not be added unless a contributor steps up to build and maintain them. All active contributors are on modern systems and busy with higher priority tasks. Whether the emulator runs on Windows Vista or not doesn't matter if it can't run games. Does Xenia run on Linux or macOS? Not natively, but Xenia may run with Wine on Linux using Vulkan . D3D12 will only work on Windows 10+ due to vkd3d not being supported. macOS is not compatible due to requiring MoltenVK/Metal support which isn't implemented in Xenia. Can I dump games using an Xbox One/Series S|X or run them directly from the disc? No, and no. Why is my game in trial/demo mode? See this option . How do I use xenia-vfs-dump? xenia-vfs-dump is a command-line tool use for dumping content from STFS and SVOD containers. You can download it from here . Usage: xenia-vfs-dump [[DestinationOutput](ContainerPath]) Does game X run? Check the compatibility list . If it's not there, ask in the Discord #help channel or test it yourself. What's the difference between Gameplay and Playable? Gameplay means the game reaches gameplay, even if the game is unplayable. Why aren't saves working? (Storage device not found/full/not detected, etc) Saves are broken in some games in Xenia, especially ones with user profile saves. As for saves, etc that worked previously in older builds of Xenia, create a text file in the same directory as xenia.exe named portable.txt . Where are saves stored? Saves are in Documents\\xenia\\content by default. If a portable.txt file is in the same directory as xenia.exe the content folder will be in the same directory as xenia.exe . Can Xenia play games online with Xbox Live? Xenia may connect to custom servers in the far future, but it will never connect to official Xbox Live servers. Xenia does not support System Link either. How do I check my FPS? With an FPS indicator like Rivatuner . What is ROV? See ROV What are Xenia's options? See the Options page . Can Xenia run original Xbox games? Xenia does not support backwards compatibility, and therefore, cannot run original Xbox games. For that there's Cxbx-Reloaded , xqemu , and Xemu . I have a copy of the XDK. Do you want it? No. Do not post links or downloads to such resources or you will be banned . Game patches Refer to the game-patches repository .","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#how-do-i-use-xenia","text":"Refer to the Quickstart page .","title":"How do I use Xenia?"},{"location":"faq/#what-are-xenias-system-requirements","text":"See the Quickstart page","title":"What are Xenia's system requirements?"},{"location":"faq/#how-do-i-fix-the-vcruntime-error","text":"Refer to the Quickstart page .","title":"How do I fix the VCRUNTIME error?"},{"location":"faq/#why-do-i-get-an-error-saying-your-cpu-does-not-support-avx","text":"Your CPU doesn't meet the minimum requirements. See the Quickstart page","title":"Why do I get an error saying \"Your CPU does not support AVX\"?"},{"location":"faq/#how-do-i-dump-games","text":"See the guide in Quickstart .","title":"How do I dump games?"},{"location":"faq/#how-do-i-improve-performance","text":"Upgrade your PC or wait for optimizations.","title":"How do I improve performance?"},{"location":"faq/#does-xenia-support-opengldirect3d11","text":"No. (see the system requirements )","title":"Does Xenia support OpenGL/Direct3D11?"},{"location":"faq/#why-is-the-audio-delayed","text":"Audio is one of the least worked on things in Xenia. There is no fix.","title":"Why is the audio delayed?"},{"location":"faq/#how-do-i-fix-graphics-device-lost-probably-due-to-an-internal-error","text":"You can't.","title":"How do I fix \"Graphics device lost (probably due to an internal error\"?"},{"location":"faq/#can-you-add-support-for-windows-me-how-about-my-pentium-ii","text":"Support for older operating systems and processors will not be added unless a contributor steps up to build and maintain them. All active contributors are on modern systems and busy with higher priority tasks. Whether the emulator runs on Windows Vista or not doesn't matter if it can't run games.","title":"Can you add support for Windows Me? How about my Pentium II?"},{"location":"faq/#does-xenia-run-on-linux-or-macos","text":"Not natively, but Xenia may run with Wine on Linux using Vulkan . D3D12 will only work on Windows 10+ due to vkd3d not being supported. macOS is not compatible due to requiring MoltenVK/Metal support which isn't implemented in Xenia.","title":"Does Xenia run on Linux or macOS?"},{"location":"faq/#can-i-dump-games-using-an-xbox-oneseries-sx-or-run-them-directly-from-the-disc","text":"No, and no.","title":"Can I dump games using an Xbox One/Series S|X or run them directly from the disc?"},{"location":"faq/#why-is-my-game-in-trialdemo-mode","text":"See this option .","title":"Why is my game in trial/demo mode?"},{"location":"faq/#how-do-i-use-xenia-vfs-dump","text":"xenia-vfs-dump is a command-line tool use for dumping content from STFS and SVOD containers. You can download it from here . Usage: xenia-vfs-dump [[DestinationOutput](ContainerPath])","title":"How do I use xenia-vfs-dump?"},{"location":"faq/#does-game-x-run","text":"Check the compatibility list . If it's not there, ask in the Discord #help channel or test it yourself.","title":"Does game X run?"},{"location":"faq/#whats-the-difference-between-gameplay-and-playable","text":"Gameplay means the game reaches gameplay, even if the game is unplayable.","title":"What's the difference between Gameplay and Playable?"},{"location":"faq/#why-arent-saves-working-storage-device-not-foundfullnot-detected-etc","text":"Saves are broken in some games in Xenia, especially ones with user profile saves. As for saves, etc that worked previously in older builds of Xenia, create a text file in the same directory as xenia.exe named portable.txt .","title":"Why aren't saves working? (Storage device not found/full/not detected, etc)"},{"location":"faq/#where-are-saves-stored","text":"Saves are in Documents\\xenia\\content by default. If a portable.txt file is in the same directory as xenia.exe the content folder will be in the same directory as xenia.exe .","title":"Where are saves stored?"},{"location":"faq/#can-xenia-play-games-online-with-xbox-live","text":"Xenia may connect to custom servers in the far future, but it will never connect to official Xbox Live servers. Xenia does not support System Link either.","title":"Can Xenia play games online with Xbox Live?"},{"location":"faq/#how-do-i-check-my-fps","text":"With an FPS indicator like Rivatuner .","title":"How do I check my FPS?"},{"location":"faq/#what-is-rov","text":"See ROV","title":"What is ROV?"},{"location":"faq/#what-are-xenias-options","text":"See the Options page .","title":"What are Xenia's options?"},{"location":"faq/#can-xenia-run-original-xbox-games","text":"Xenia does not support backwards compatibility, and therefore, cannot run original Xbox games. For that there's Cxbx-Reloaded , xqemu , and Xemu .","title":"Can Xenia run original Xbox games?"},{"location":"faq/#i-have-a-copy-of-the-xdk-do-you-want-it","text":"No. Do not post links or downloads to such resources or you will be banned .","title":"I have a copy of the XDK. Do you want it?"},{"location":"faq/#game-patches","text":"Refer to the game-patches repository .","title":"Game patches"},{"location":"faq/roadmap/","text":"Goals Normal emulator stuff. Games work, etc. Cross-platform Support Linux support is slowly progressing, but really needs a strong contributor to fully support. macOS support is highly unlikely unless Apple gets Vulkan support. Non-Goals There's a lot that could be done in the project, but there are many things that shouldn't be. Pixel-perfect Accuracy A lot of corners are cut for one reason or another: performance, lack of understanding, lack of documentation, etc. Getting something that perfectly matches the output on a real console isn't really possible with our approach. Conversely, this allows much more freedom to provide higher-quality or faster implementations. Xbox Live Connectivity Xenia will never be able to connect to the real Xbox Live network. A simulated Live-like network is possible, however anything that interfaces with the official Microsoft services is not only not possible, but not something the project seeks to enable. Game Servers Some multiplayer games are peer-to-peer, however many have some server component required for either matchmaking or actual session hosting. Though it'd be possible to work with such homebrew servers if projects sprung up to support them Xenia itself will not be attempting to do so. Original Xbox Backwards Compatibility Microsoft released a compatibility layer that enabled original Xbox games to run on the 360. Though likely feasible to get running under Xenia, it's not a goal. There's likely to be a lot of trickery going on that most games don't do, and distribution of the compatibility layer isn't possible. Dreams VR Figure that out :) Simulated Xbox Live Network Implement the system APIs for friend's list, leaderboards, etc. Reusing Steam or some other service would be ideal.","title":"Roadmap"},{"location":"faq/roadmap/#goals","text":"Normal emulator stuff. Games work, etc.","title":"Goals"},{"location":"faq/roadmap/#cross-platform-support","text":"Linux support is slowly progressing, but really needs a strong contributor to fully support. macOS support is highly unlikely unless Apple gets Vulkan support.","title":"Cross-platform Support"},{"location":"faq/roadmap/#non-goals","text":"There's a lot that could be done in the project, but there are many things that shouldn't be.","title":"Non-Goals"},{"location":"faq/roadmap/#pixel-perfect-accuracy","text":"A lot of corners are cut for one reason or another: performance, lack of understanding, lack of documentation, etc. Getting something that perfectly matches the output on a real console isn't really possible with our approach. Conversely, this allows much more freedom to provide higher-quality or faster implementations.","title":"Pixel-perfect Accuracy"},{"location":"faq/roadmap/#xbox-live-connectivity","text":"Xenia will never be able to connect to the real Xbox Live network. A simulated Live-like network is possible, however anything that interfaces with the official Microsoft services is not only not possible, but not something the project seeks to enable.","title":"Xbox Live Connectivity"},{"location":"faq/roadmap/#game-servers","text":"Some multiplayer games are peer-to-peer, however many have some server component required for either matchmaking or actual session hosting. Though it'd be possible to work with such homebrew servers if projects sprung up to support them Xenia itself will not be attempting to do so.","title":"Game Servers"},{"location":"faq/roadmap/#original-xbox-backwards-compatibility","text":"Microsoft released a compatibility layer that enabled original Xbox games to run on the 360. Though likely feasible to get running under Xenia, it's not a goal. There's likely to be a lot of trickery going on that most games don't do, and distribution of the compatibility layer isn't possible.","title":"Original Xbox Backwards Compatibility"},{"location":"faq/roadmap/#dreams","text":"","title":"Dreams"},{"location":"faq/roadmap/#vr","text":"Figure that out :)","title":"VR"},{"location":"faq/roadmap/#simulated-xbox-live-network","text":"Implement the system APIs for friend's list, leaderboards, etc. Reusing Steam or some other service would be ideal.","title":"Simulated Xbox Live Network"},{"location":"faq/rov/","text":"Improves accuracy at the cost of performance. Recommended to be disabled . Long ROV (rasterizer-ordered views) explanation [click to expand] The Direct3D 12 version of Xenia has two code paths for rendering output (the currently used one is displayed in the window title bar): \"RT\" (Render Target Views) and \"ROV\" (Rasterizer-Ordered Views). On the Xbox 360, pixels are written to a 10 MB memory chip called the eDRAM, and many games reinterpret the data in it in different formats for various purposes (clearing, HDR rendering, etc.) This is not the case on PC, where different render targets are independent from each other. The \"RT\" path uses conventional PC render targets (RTV \u2014 Render Target Views \u2014 and DSV \u2014 Depth-Stencil Views \u2014 in Direct3D terms) for rendering output, and copies data between PC render target textures and the 10 MB buffer to allow for reinterpretation of eDRAM data in different formats. However, copying has a very heavy performance impact, causing noticeable slowdowns even on modern graphics cards. Another issue is that the Xbox 360 has certain render target formats not available on the PC (7e3 HDR floating-point, 16-bit fixed-point with \u221232\u202632 range, 20e4 floating-point depth) that have to be approximated with other render target formats. This causes unfixable transparency issues (because the blending hardware works with different ranges and precision of numbers) and depth buffer-related issues such as shadow acne. Using the Rasterizer-Ordered Views (ROV) feature of Direct3D 12 allows Xenia to overcome those issues by doing blending and depth/stencil testing manually in pixel shaders, rendering directly to the 10 MB buffer. This allows for much higher performance since there's no expensive data copying, and better accuracy because of no pixel format limitations. \"Rasterizer-ordered\" here means that access to the buffer is synchronized \u2014 if multiple polygons in a single draw call are covering the same pixel, the buffer will be accessed in the correct order, without conflicts that would happen if the data was written through a regular unordered access view (UAV). You can read more about this feature at https://software.intel.com/en-us/gamedev/articles/rasterizer-order-views-101-a-primer, another common use for ROV in game development is order-independent transparency algorithms. However, this is a hardware feature, and thus on older graphics cards, Xenia is limited to the RT path. Rasterizer-ordered views are used by default in Xenia where available, but if you're experiencing graphical issues, you may try [disabling it in the config](Options/#disable-rov-rasterizer-ordered-views). The minimum requirements for ROV are: * Nvidia GeForce GTX 950 on desktops, GTX 965M on laptops (Maxwell 2nd generation \u2014 2014) * AMD Radeon Vega (GCN 5th generation \u2014 2017) * Intel HD Graphics 4200 (2013)","title":"Rov"},{"location":"faq/options/","text":"Options / Configuration How to use Run xenia if you haven't before. Show file name extensions in Explorer . Go to Documents\\Xenia and open xenia.config.toml in a text editor like Notepad++ . If a portable.txt file is present in the same directory as xenia.exe it will be in the same directory as xenia.exe . Per-game configs go in config\\TitleID.config.toml . Note that per-game configs are highly unstable , only very few options can be changed from it safely or at all, as most emulator subsystems are initialized before per-game configs are loaded. For launchers/frontends like Bottlenose you can use the --config launch parameter to specify what config to use. To launch specific games, add the path to the game before the launch options. For example: xenia.exe path/to/game/default.xex --vsync=false Config Settings Each setting has a table explaining the different options. Expand a section by clicking it to see the table. setting_name value type description value APU CPU Break on Unimplemented Instructions | break_on_unimplemented_instructions | bool | |:--------------------------------------|:------:| | On ( default ) | true | | Off (hack, needed for certain games )| false | Config Content License Mask | license_mask | # | |:------------------------------------------|:-------:| | Deactivated/trial/demo mode ( default ) | 0 | | Activated/full mode | -1 or 1 | D3D12 CPU Readback After Render Target Resolving This is needed for certain games: Titles that might require this option d3d12_readback_resolve bool Off ( default ) false On true Display GPU Allow Invalid Fetch Constants Allow texture and vertex fetch constants with invalid type - generally unsafe because the constant may contain completely invalid values, but may be used to bypass fetch constant type errors in certain games until the real reason why they're invalid is found. gpu_allow_invalid_fetch_constants bool Off ( default ) false On (hack) true Renderer/Backend gpu string Any backend ( default, recommended ) any Direct3D 12 d3d12 Vulkan vulkan Null (blank/nothing) null Render target path Leave this option blank for auto-selection. | render_target_path_d3d12 | string | |:----------------------------------------------------------|:--------:| | Auto-selection | | | RTV (recommended for speed) | rtv | | ROV ( if available , for higher accuracy in certain cases)| rov | What is ROV (rasterizer-ordered views)? Resolution Scaling This is a hack, and as such, bugs should be expected . Scale X Scale Y Horizontal Scale draw_resolution_scale_x # 1x ( default , 1280x) 1 2x (2560x) 2 3x (3840x) 3 Vertical Scale: draw_resolution_scale_y # 1x ( default , 720x) 1 2x (1440x) 2 3x (2160x) 3 Vertical Sync | vsync | bool | |:-----------------|:------:| | On ( default ) | true | | Off (uncaps FPS) | false | This won\u2019t improve the framerate if your PC can\u2019t handle running the game at its native FPS. This doesn\u2019t work with all games General HID Input Backend This option controls which backend the controller is mapped to. hid string Any input method ( default ) any SDL2* sdl XInput xinput Keyboard winkey SDL supports many controllers and many advanced features (not all of them are implemented). SDL supports an ever-growing list of controllers. XInput supports all Xbox controllers starting with the Xbox 360, including the Guitar Hero and Rock Band instruments. Wireless Xbox 360 controllers and some Wireless Xbox One controllers require you to own a USB wireless adapter. WinKey only supports keyboards that are compatible with your device. When using SDL If your game controller is not mapped correctly, download gamecontrollerdb.txt and place it in the folder next to your Xenia executable. HID WinKey Windows Key Bindings The following settings all follow the same rules. The value must be a key identifier, or multiple key identifiers separated by spaces. Modifiers may be added in front of key identifiers to change the meaning of a bind while another key is pressed. Key identifiers Virtual-Key Codes (hex) A character corresponding to a key Key modifiers Modifier Meaning _ only with Caps Lock enabled ^ only while Shift is pressed Examples Setting and Value Meaning keybind_a = \"0xBA\" Bind to ; keybind_x = \"X\" Bind to X keybind_y = \"Y U 0xA0\" Bind to Y , U or Left Shift keybind_b = \"_0xBA\" Bind to ; only when Caps Lock is enabled keybind_dpad_up = \"^X\" Bind to Shift + X Default bindings Setting Name Default Value Meaning keybind_a 0xBA Bind to ; keybind_b 0xDE Bind to \" keybind_back Z Bind to Z keybind_dpad_down ^S Bind to S (Caps Lock on) keybind_dpad_left ^A Bind to A (Caps Lock on) keybind_dpad_right ^D Bind to D (Caps Lock on) keybind_dpad_up ^W Bind to W (Caps Lock on) keybind_left_shoulder 1 Bind to 1 keybind_left_thumb F Bind to F keybind_left_thumb_down _S Bind to Shift + S keybind_left_thumb_left _A Bind to Shift + A keybind_left_thumb_right _D Bind to Shift + D keybind_left_thumb_up _W Bind to Shift + W keybind_left_trigger Q I Bind to Q or I keybind_right_shoulder 3 Bind to 3 keybind_right_thumb K Bind to K keybind_right_thumb_down 0x28 Bind to Up keybind_right_thumb_left 0x25 Bind to Left keybind_right_thumb_right 0x27 Bind to Right keybind_right_thumb_up 0x26 Bind to Up keybind_right_trigger E O Bind to E or O keybind_start X Bind to X keybind_x L Bind to L keybind_y P Bind to P Kernel Logging Memory Protect Zero protect_zero bool On ( default ) true Off (hack, needed for certain games*) false Certain games require this to set be set to false to work around crashes. This includes, but isn't limited to: Saints Row 1 SDL Storage UI Vulkan Win32 XConfig User Language user_language # region code native name English ( default ) 1 EN English Japanese 2 JA \u65e5\u672c\u8a9e German 3 DE Deutsche French 4 FR Fran\u00e7ais Spanish 5 ES Espa\u00f1ol Italian 6 IT Italiano Korean 7 KO \ud55c\uad6d\uc5b4 Traditional Chinese 8 ZH \u7e41\u9ad4\u4e2d\u6587 Portuguese 9 PT Portugu\u00eas Polish 10 PL Polski Russian 11 RU \u0440\u0443\u0441\u0441\u043a\u0438\u0439 Swedish 12 SV Svenska Turkish 13 TR T\u00fcrk Norwegian 14 NB Norsk Dutch 15 NL Nederlands Simplified Chinese 16 ZH \u7b80\u4f53\u4e2d\u6587 x64","title":"Options / Configuration"},{"location":"faq/options/#options-configuration","text":"","title":"Options / Configuration"},{"location":"faq/options/#how-to-use","text":"Run xenia if you haven't before. Show file name extensions in Explorer . Go to Documents\\Xenia and open xenia.config.toml in a text editor like Notepad++ . If a portable.txt file is present in the same directory as xenia.exe it will be in the same directory as xenia.exe . Per-game configs go in config\\TitleID.config.toml . Note that per-game configs are highly unstable , only very few options can be changed from it safely or at all, as most emulator subsystems are initialized before per-game configs are loaded. For launchers/frontends like Bottlenose you can use the --config launch parameter to specify what config to use. To launch specific games, add the path to the game before the launch options. For example: xenia.exe path/to/game/default.xex --vsync=false","title":"How to use"},{"location":"faq/options/#config-settings","text":"Each setting has a table explaining the different options. Expand a section by clicking it to see the table. setting_name value type description value","title":"Config Settings"},{"location":"faq/options/#apu","text":"","title":"APU"},{"location":"faq/options/#cpu","text":"Break on Unimplemented Instructions | break_on_unimplemented_instructions | bool | |:--------------------------------------|:------:| | On ( default ) | true | | Off (hack, needed for certain games )| false |","title":"CPU"},{"location":"faq/options/#config","text":"","title":"Config"},{"location":"faq/options/#content","text":"License Mask | license_mask | # | |:------------------------------------------|:-------:| | Deactivated/trial/demo mode ( default ) | 0 | | Activated/full mode | -1 or 1 |","title":"Content"},{"location":"faq/options/#d3d12","text":"CPU Readback After Render Target Resolving This is needed for certain games: Titles that might require this option d3d12_readback_resolve bool Off ( default ) false On true","title":"D3D12"},{"location":"faq/options/#display","text":"","title":"Display"},{"location":"faq/options/#gpu","text":"Allow Invalid Fetch Constants Allow texture and vertex fetch constants with invalid type - generally unsafe because the constant may contain completely invalid values, but may be used to bypass fetch constant type errors in certain games until the real reason why they're invalid is found. gpu_allow_invalid_fetch_constants bool Off ( default ) false On (hack) true Renderer/Backend gpu string Any backend ( default, recommended ) any Direct3D 12 d3d12 Vulkan vulkan Null (blank/nothing) null Render target path Leave this option blank for auto-selection. | render_target_path_d3d12 | string | |:----------------------------------------------------------|:--------:| | Auto-selection | | | RTV (recommended for speed) | rtv | | ROV ( if available , for higher accuracy in certain cases)| rov | What is ROV (rasterizer-ordered views)? Resolution Scaling This is a hack, and as such, bugs should be expected . Scale X Scale Y Horizontal Scale draw_resolution_scale_x # 1x ( default , 1280x) 1 2x (2560x) 2 3x (3840x) 3 Vertical Scale: draw_resolution_scale_y # 1x ( default , 720x) 1 2x (1440x) 2 3x (2160x) 3 Vertical Sync | vsync | bool | |:-----------------|:------:| | On ( default ) | true | | Off (uncaps FPS) | false | This won\u2019t improve the framerate if your PC can\u2019t handle running the game at its native FPS. This doesn\u2019t work with all games","title":"GPU"},{"location":"faq/options/#general","text":"","title":"General"},{"location":"faq/options/#hid","text":"Input Backend This option controls which backend the controller is mapped to. hid string Any input method ( default ) any SDL2* sdl XInput xinput Keyboard winkey SDL supports many controllers and many advanced features (not all of them are implemented). SDL supports an ever-growing list of controllers. XInput supports all Xbox controllers starting with the Xbox 360, including the Guitar Hero and Rock Band instruments. Wireless Xbox 360 controllers and some Wireless Xbox One controllers require you to own a USB wireless adapter. WinKey only supports keyboards that are compatible with your device. When using SDL If your game controller is not mapped correctly, download gamecontrollerdb.txt and place it in the folder next to your Xenia executable.","title":"HID"},{"location":"faq/options/#hid-winkey","text":"Windows Key Bindings The following settings all follow the same rules. The value must be a key identifier, or multiple key identifiers separated by spaces. Modifiers may be added in front of key identifiers to change the meaning of a bind while another key is pressed.","title":"HID WinKey"},{"location":"faq/options/#key-identifiers","text":"Virtual-Key Codes (hex) A character corresponding to a key","title":"Key identifiers"},{"location":"faq/options/#key-modifiers","text":"Modifier Meaning _ only with Caps Lock enabled ^ only while Shift is pressed","title":"Key modifiers"},{"location":"faq/options/#examples","text":"Setting and Value Meaning keybind_a = \"0xBA\" Bind to ; keybind_x = \"X\" Bind to X keybind_y = \"Y U 0xA0\" Bind to Y , U or Left Shift keybind_b = \"_0xBA\" Bind to ; only when Caps Lock is enabled keybind_dpad_up = \"^X\" Bind to Shift + X","title":"Examples"},{"location":"faq/options/#default-bindings","text":"Setting Name Default Value Meaning keybind_a 0xBA Bind to ; keybind_b 0xDE Bind to \" keybind_back Z Bind to Z keybind_dpad_down ^S Bind to S (Caps Lock on) keybind_dpad_left ^A Bind to A (Caps Lock on) keybind_dpad_right ^D Bind to D (Caps Lock on) keybind_dpad_up ^W Bind to W (Caps Lock on) keybind_left_shoulder 1 Bind to 1 keybind_left_thumb F Bind to F keybind_left_thumb_down _S Bind to Shift + S keybind_left_thumb_left _A Bind to Shift + A keybind_left_thumb_right _D Bind to Shift + D keybind_left_thumb_up _W Bind to Shift + W keybind_left_trigger Q I Bind to Q or I keybind_right_shoulder 3 Bind to 3 keybind_right_thumb K Bind to K keybind_right_thumb_down 0x28 Bind to Up keybind_right_thumb_left 0x25 Bind to Left keybind_right_thumb_right 0x27 Bind to Right keybind_right_thumb_up 0x26 Bind to Up keybind_right_trigger E O Bind to E or O keybind_start X Bind to X keybind_x L Bind to L keybind_y P Bind to P","title":"Default bindings"},{"location":"faq/options/#kernel","text":"","title":"Kernel"},{"location":"faq/options/#logging","text":"","title":"Logging"},{"location":"faq/options/#memory","text":"Protect Zero protect_zero bool On ( default ) true Off (hack, needed for certain games*) false Certain games require this to set be set to false to work around crashes. This includes, but isn't limited to: Saints Row 1","title":"Memory"},{"location":"faq/options/#sdl","text":"","title":"SDL"},{"location":"faq/options/#storage","text":"","title":"Storage"},{"location":"faq/options/#ui","text":"","title":"UI"},{"location":"faq/options/#vulkan","text":"","title":"Vulkan"},{"location":"faq/options/#win32","text":"","title":"Win32"},{"location":"faq/options/#xconfig","text":"User Language user_language # region code native name English ( default ) 1 EN English Japanese 2 JA \u65e5\u672c\u8a9e German 3 DE Deutsche French 4 FR Fran\u00e7ais Spanish 5 ES Espa\u00f1ol Italian 6 IT Italiano Korean 7 KO \ud55c\uad6d\uc5b4 Traditional Chinese 8 ZH \u7e41\u9ad4\u4e2d\u6587 Portuguese 9 PT Portugu\u00eas Polish 10 PL Polski Russian 11 RU \u0440\u0443\u0441\u0441\u043a\u0438\u0439 Swedish 12 SV Svenska Turkish 13 TR T\u00fcrk Norwegian 14 NB Norsk Dutch 15 NL Nederlands Simplified Chinese 16 ZH \u7b80\u4f53\u4e2d\u6587","title":"XConfig"},{"location":"faq/options/#x64","text":"","title":"x64"},{"location":"faq/options/content/license_mask/","text":"license_mask # Deactivated/trial/demo mode ( default ) 0 Activated/full mode -1 or 1","title":"License Mask"},{"location":"faq/options/cpu/break_on_unimplemented_instructions/","text":"break_on_unimplemented_instructions bool On ( default ) true Off (hack, needed for certain games ) false","title":"Break On Unimplemented"},{"location":"faq/options/d3d12/d3d12_readback_resolve/","text":"This is needed for certain games: Titles that might require this option d3d12_readback_resolve bool Off ( default ) false On true","title":"Readback Resolve"},{"location":"faq/options/gpu/draw_resolution_scale_x/","text":"Horizontal Scale draw_resolution_scale_x # 1x ( default , 1280x) 1 2x (2560x) 2 3x (3840x) 3","title":"Resolution Scale X"},{"location":"faq/options/gpu/draw_resolution_scale_y/","text":"Vertical Scale: draw_resolution_scale_y # 1x ( default , 720x) 1 2x (1440x) 2 3x (2160x) 3","title":"Resolution Scale Y"},{"location":"faq/options/gpu/gpu/","text":"gpu string Any backend ( default, recommended ) any Direct3D 12 d3d12 Vulkan vulkan Null (blank/nothing) null","title":"Renderer/Backend"},{"location":"faq/options/gpu/gpu_allow_invalid_fetch_constants/","text":"Allow texture and vertex fetch constants with invalid type - generally unsafe because the constant may contain completely invalid values, but may be used to bypass fetch constant type errors in certain games until the real reason why they're invalid is found. gpu_allow_invalid_fetch_constants bool Off ( default ) false On (hack) true","title":"Invalid Fetch Constants"},{"location":"faq/options/gpu/render_target_path_d3d12/","text":"Leave this option blank for auto-selection. | render_target_path_d3d12 | string | |:----------------------------------------------------------|:--------:| | Auto-selection | | | RTV (recommended for speed) | rtv | | ROV ( if available , for higher accuracy in certain cases)| rov | What is ROV (rasterizer-ordered views)?","title":"Render Target Path"},{"location":"faq/options/gpu/vsync/","text":"vsync bool On ( default ) true Off (uncaps FPS) false This won\u2019t improve the framerate if your PC can\u2019t handle running the game at its native FPS. This doesn\u2019t work with all games","title":"Vsync"},{"location":"faq/options/hid/hid/","text":"This option controls which backend the controller is mapped to. hid string Any input method ( default ) any SDL2* sdl XInput xinput Keyboard winkey SDL supports many controllers and many advanced features (not all of them are implemented). SDL supports an ever-growing list of controllers. XInput supports all Xbox controllers starting with the Xbox 360, including the Guitar Hero and Rock Band instruments. Wireless Xbox 360 controllers and some Wireless Xbox One controllers require you to own a USB wireless adapter. WinKey only supports keyboards that are compatible with your device. When using SDL If your game controller is not mapped correctly, download gamecontrollerdb.txt and place it in the folder next to your Xenia executable.","title":"Input Backend"},{"location":"faq/options/hid/winkey/winkey/","text":"The following settings all follow the same rules. The value must be a key identifier, or multiple key identifiers separated by spaces. Modifiers may be added in front of key identifiers to change the meaning of a bind while another key is pressed. Key identifiers Virtual-Key Codes (hex) A character corresponding to a key Key modifiers Modifier Meaning _ only with Caps Lock enabled ^ only while Shift is pressed Examples Setting and Value Meaning keybind_a = \"0xBA\" Bind to ; keybind_x = \"X\" Bind to X keybind_y = \"Y U 0xA0\" Bind to Y , U or Left Shift keybind_b = \"_0xBA\" Bind to ; only when Caps Lock is enabled keybind_dpad_up = \"^X\" Bind to Shift + X Default bindings Setting Name Default Value Meaning keybind_a 0xBA Bind to ; keybind_b 0xDE Bind to \" keybind_back Z Bind to Z keybind_dpad_down ^S Bind to S (Caps Lock on) keybind_dpad_left ^A Bind to A (Caps Lock on) keybind_dpad_right ^D Bind to D (Caps Lock on) keybind_dpad_up ^W Bind to W (Caps Lock on) keybind_left_shoulder 1 Bind to 1 keybind_left_thumb F Bind to F keybind_left_thumb_down _S Bind to Shift + S keybind_left_thumb_left _A Bind to Shift + A keybind_left_thumb_right _D Bind to Shift + D keybind_left_thumb_up _W Bind to Shift + W keybind_left_trigger Q I Bind to Q or I keybind_right_shoulder 3 Bind to 3 keybind_right_thumb K Bind to K keybind_right_thumb_down 0x28 Bind to Up keybind_right_thumb_left 0x25 Bind to Left keybind_right_thumb_right 0x27 Bind to Right keybind_right_thumb_up 0x26 Bind to Up keybind_right_trigger E O Bind to E or O keybind_start X Bind to X keybind_x L Bind to L keybind_y P Bind to P","title":"HID WinKey"},{"location":"faq/options/hid/winkey/winkey/#key-identifiers","text":"Virtual-Key Codes (hex) A character corresponding to a key","title":"Key identifiers"},{"location":"faq/options/hid/winkey/winkey/#key-modifiers","text":"Modifier Meaning _ only with Caps Lock enabled ^ only while Shift is pressed","title":"Key modifiers"},{"location":"faq/options/hid/winkey/winkey/#examples","text":"Setting and Value Meaning keybind_a = \"0xBA\" Bind to ; keybind_x = \"X\" Bind to X keybind_y = \"Y U 0xA0\" Bind to Y , U or Left Shift keybind_b = \"_0xBA\" Bind to ; only when Caps Lock is enabled keybind_dpad_up = \"^X\" Bind to Shift + X","title":"Examples"},{"location":"faq/options/hid/winkey/winkey/#default-bindings","text":"Setting Name Default Value Meaning keybind_a 0xBA Bind to ; keybind_b 0xDE Bind to \" keybind_back Z Bind to Z keybind_dpad_down ^S Bind to S (Caps Lock on) keybind_dpad_left ^A Bind to A (Caps Lock on) keybind_dpad_right ^D Bind to D (Caps Lock on) keybind_dpad_up ^W Bind to W (Caps Lock on) keybind_left_shoulder 1 Bind to 1 keybind_left_thumb F Bind to F keybind_left_thumb_down _S Bind to Shift + S keybind_left_thumb_left _A Bind to Shift + A keybind_left_thumb_right _D Bind to Shift + D keybind_left_thumb_up _W Bind to Shift + W keybind_left_trigger Q I Bind to Q or I keybind_right_shoulder 3 Bind to 3 keybind_right_thumb K Bind to K keybind_right_thumb_down 0x28 Bind to Up keybind_right_thumb_left 0x25 Bind to Left keybind_right_thumb_right 0x27 Bind to Right keybind_right_thumb_up 0x26 Bind to Up keybind_right_trigger E O Bind to E or O keybind_start X Bind to X keybind_x L Bind to L keybind_y P Bind to P","title":"Default bindings"},{"location":"faq/options/memory/protect_zero/","text":"protect_zero bool On ( default ) true Off (hack, needed for certain games*) false Certain games require this to set be set to false to work around crashes. This includes, but isn't limited to: Saints Row 1","title":"Protect Zero"},{"location":"faq/options/xconfig/user_language/","text":"user_language # region code native name English ( default ) 1 EN English Japanese 2 JA \u65e5\u672c\u8a9e German 3 DE Deutsche French 4 FR Fran\u00e7ais Spanish 5 ES Espa\u00f1ol Italian 6 IT Italiano Korean 7 KO \ud55c\uad6d\uc5b4 Traditional Chinese 8 ZH \u7e41\u9ad4\u4e2d\u6587 Portuguese 9 PT Portugu\u00eas Polish 10 PL Polski Russian 11 RU \u0440\u0443\u0441\u0441\u043a\u0438\u0439 Swedish 12 SV Svenska Turkish 13 TR T\u00fcrk Norwegian 14 NB Norsk Dutch 15 NL Nederlands Simplified Chinese 16 ZH \u7b80\u4f53\u4e2d\u6587","title":"User Language"},{"location":"faq/quickstart/","text":"Quickstart Guide Welcome to the Xenia Xbox 360 Emulator. The following sections will explain the minimum requirements and recommended hardware for Xenia, how to install it, and how to dump games for use in Xenia. See also: Already know how to use Xenia? Want to help out? Check out the Xenia contribution guide . Want to contribute to the wiki? Check out the wiki contribution guide . Next section.... System Requirements","title":"Quickstart Guide"},{"location":"faq/quickstart/#quickstart-guide","text":"Welcome to the Xenia Xbox 360 Emulator. The following sections will explain the minimum requirements and recommended hardware for Xenia, how to install it, and how to dump games for use in Xenia. See also: Already know how to use Xenia? Want to help out? Check out the Xenia contribution guide . Want to contribute to the wiki? Check out the wiki contribution guide . Next section.... System Requirements","title":"Quickstart Guide"},{"location":"faq/quickstart/activate_games/","text":"By default Xenia runs ALL XBLA/digital games in demo/trial mode. To run games in full/activated mode you need to change this option .","title":"Activating Games and DLC"},{"location":"faq/quickstart/download/","text":"Where do I download Xenia? Xenia Emulator Logo image/svg+xml Xenia Emulator Logo 28-05-2019 SVG Remake of Xenia Logo by Kwasior/@ThisKwasior Master Xenia Emulator Logo image/svg+xml Xenia Emulator Logo 28-05-2019 SVG Remake of Xenia Logo by Kwasior/@ThisKwasior Canary Xenia Canary is a fork of Xenia with changes not present in master. Xenia is sometimes detected as a virus. Ignore this, as it is a false positive. For more information: What is the difference between Xenia Canary and Xenia master? Next section... How to Dump Games","title":"Where to Download"},{"location":"faq/quickstart/download/#where-do-i-download-xenia","text":"Xenia Emulator Logo image/svg+xml Xenia Emulator Logo 28-05-2019 SVG Remake of Xenia Logo by Kwasior/@ThisKwasior Master Xenia Emulator Logo image/svg+xml Xenia Emulator Logo 28-05-2019 SVG Remake of Xenia Logo by Kwasior/@ThisKwasior Canary Xenia Canary is a fork of Xenia with changes not present in master. Xenia is sometimes detected as a virus. Ignore this, as it is a false positive. For more information: What is the difference between Xenia Canary and Xenia master? Next section... How to Dump Games","title":"Where do I download Xenia?"},{"location":"faq/quickstart/dumping/","text":"How to Rip / Dump Games YOU CANNOT PLAY GAMES DIRECTLY FROM THE DISC DRIVE, OR USE AN XBOX ONE/SERIES TO RIP GAMES! Stock console method Requirements Xbox 360 console USB storage device that's at least 16GB. You might encounter problems with smaller devices. Velocity If you're wanting to rip games from disc: * Xbox 360 game disc * Xbox 360 that can read discs Preparation Before beginning, you need to check if the USB is formatted: Go to Settings > System > Storage Settings > System: Storage: If you see an Unformatted storage device, select it. Image (click to expand) Unformatted: If it's already formatted, skip this section. Press A to format Select Yes Press A to format: Select Yes: This will erase everything from the drive. Make sure to move the files off of it first! Once done, return to home by pressing B twice. 1. Ripping discs If your game isn't a disc (XBLA, digital, etc.) skip to Section 2. You'll want to change these options to stop game(s) from automatically starting: Settings > System > Console Settings > Auto-Play > Disable Settings > System: Console Settings: Auto-Play: Disable: Settings > System > Console Settings > Startup and Shutdown > Startup > Xbox Dashboard Settings > System: Console Settings: Startup and Shutdown: Startup: Xbox Dashboard: Go to home on the dashboard Insert the disc into the drive, and close the tray. Once the game shows up press X (Game Details) with the game selected. Press the Install button. If you see Delete instead, skip to Section 2. Note: Not all games have the Install option. List of currently known uninstallable games: College Hoops 2k7 Minecraft Pocket Bike Racers Sneak King Crackdown (Can be installed with latest title update) Dead or Alive Xtreme 2 Select the storage device you want to install the game on. Once it's 100% Completed press A to continue, and press B to go back to home. 2. Transferring HDD games If you ripped the game(s) directly to the USB drive, or they're already on the USB drive, you can skip this section. 1. Go to Settings > System > Storage > Hard Drive > Press Y (Device Options) > Transfer Content > USB Storage Device 4. Choose what you want to transfer. Keep in mind full games and trials/demos are in separate categories. Settings > System: Storage: Hard Drive: Press Y (Device Options): Transfer Content: USB Storage Device: Press right, then Start . Start: Once it's done you can take the USB out of the console. 3. Importing games for use in Xenia Insert the USB drive into your PC. Go to Content . If the USB drive appears empty enable Show hidden files and folders in Windows Explorer. Go into 00000# . There will be folders with names consisting of lots of letters and numbers. You should find the game's folder within one of them. The game will have a name with a bunch of letters and numbers just like the folders, and no file extension. XBLA games will be one file, GOD (disc) games will contain a file, along with a *.data folder with the same name. ContentCache.pkg is irrelevant. Ignore it. To confirm that it is indeed a game try opening the file in Xenia. Once you've made sure the file works in Xenia you can rename, or move the folder the game is in for convenience. FOLDER ABOVE, NOT FILE or *.DATA FOLDER! (Optional) If the game crashes you can try extracting the game using Velocity. If the game is extracted you will need to drag default.xex onto Xenia. Some games have multiple .xex files, so if you can't find default.xex or it just doesn't work, try another one. See also Redump Xbox and Xbox 360 dumping guide Next section... Installing DLCs Activating Licenses (DLCs and Trials)","title":"Dumping Games"},{"location":"faq/quickstart/dumping/#how-to-rip-dump-games","text":"YOU CANNOT PLAY GAMES DIRECTLY FROM THE DISC DRIVE, OR USE AN XBOX ONE/SERIES TO RIP GAMES!","title":"How to Rip / Dump Games"},{"location":"faq/quickstart/dumping/#stock-console-method","text":"","title":"Stock console method"},{"location":"faq/quickstart/dumping/#requirements","text":"Xbox 360 console USB storage device that's at least 16GB. You might encounter problems with smaller devices. Velocity If you're wanting to rip games from disc: * Xbox 360 game disc * Xbox 360 that can read discs","title":"Requirements"},{"location":"faq/quickstart/dumping/#preparation","text":"Before beginning, you need to check if the USB is formatted: Go to Settings > System > Storage Settings > System: Storage: If you see an Unformatted storage device, select it. Image (click to expand) Unformatted: If it's already formatted, skip this section. Press A to format Select Yes Press A to format: Select Yes: This will erase everything from the drive. Make sure to move the files off of it first! Once done, return to home by pressing B twice.","title":"Preparation"},{"location":"faq/quickstart/dumping/#1-ripping-discs","text":"If your game isn't a disc (XBLA, digital, etc.) skip to Section 2. You'll want to change these options to stop game(s) from automatically starting: Settings > System > Console Settings > Auto-Play > Disable Settings > System: Console Settings: Auto-Play: Disable: Settings > System > Console Settings > Startup and Shutdown > Startup > Xbox Dashboard Settings > System: Console Settings: Startup and Shutdown: Startup: Xbox Dashboard: Go to home on the dashboard Insert the disc into the drive, and close the tray. Once the game shows up press X (Game Details) with the game selected. Press the Install button. If you see Delete instead, skip to Section 2. Note: Not all games have the Install option. List of currently known uninstallable games: College Hoops 2k7 Minecraft Pocket Bike Racers Sneak King Crackdown (Can be installed with latest title update) Dead or Alive Xtreme 2 Select the storage device you want to install the game on. Once it's 100% Completed press A to continue, and press B to go back to home.","title":"1. Ripping discs"},{"location":"faq/quickstart/dumping/#2-transferring-hdd-games","text":"If you ripped the game(s) directly to the USB drive, or they're already on the USB drive, you can skip this section. 1. Go to Settings > System > Storage > Hard Drive > Press Y (Device Options) > Transfer Content > USB Storage Device 4. Choose what you want to transfer. Keep in mind full games and trials/demos are in separate categories. Settings > System: Storage: Hard Drive: Press Y (Device Options): Transfer Content: USB Storage Device: Press right, then Start . Start: Once it's done you can take the USB out of the console.","title":"2. Transferring HDD games"},{"location":"faq/quickstart/dumping/#3-importing-games-for-use-in-xenia","text":"Insert the USB drive into your PC. Go to Content . If the USB drive appears empty enable Show hidden files and folders in Windows Explorer. Go into 00000# . There will be folders with names consisting of lots of letters and numbers. You should find the game's folder within one of them. The game will have a name with a bunch of letters and numbers just like the folders, and no file extension. XBLA games will be one file, GOD (disc) games will contain a file, along with a *.data folder with the same name. ContentCache.pkg is irrelevant. Ignore it. To confirm that it is indeed a game try opening the file in Xenia. Once you've made sure the file works in Xenia you can rename, or move the folder the game is in for convenience. FOLDER ABOVE, NOT FILE or *.DATA FOLDER! (Optional) If the game crashes you can try extracting the game using Velocity. If the game is extracted you will need to drag default.xex onto Xenia. Some games have multiple .xex files, so if you can't find default.xex or it just doesn't work, try another one. See also Redump Xbox and Xbox 360 dumping guide Next section... Installing DLCs Activating Licenses (DLCs and Trials)","title":"3. Importing games for use in Xenia"},{"location":"faq/quickstart/install_dlc/","text":"How to install DLCs Identify what the Game Title ID is. This can be identified by running the game in Xenia. Locate your DLC Content folder from your removable storage. Download Velocity from here . Open the Packages with Velocity. Extract the content packages to Documents\\Xenia\\TitleID\\00000002 and their corresponding folder names. Next section... Activating Games and DLCs","title":"Installing DLC"},{"location":"faq/quickstart/install_dlc/#how-to-install-dlcs","text":"Identify what the Game Title ID is. This can be identified by running the game in Xenia. Locate your DLC Content folder from your removable storage. Download Velocity from here . Open the Packages with Velocity. Extract the content packages to Documents\\Xenia\\TitleID\\00000002 and their corresponding folder names. Next section... Activating Games and DLCs","title":"How to install DLCs"},{"location":"faq/quickstart/system_requirements/","text":"System Requirements Meeting recommended specifications won't guarantee perfect performance. How to find relevant specs in Speccy on Windows On the first page, you'll find your operating system, CPU, GPU, and amount of RAM. On the CPU page, you'll find your CPU instruction extensions. (Look for AVX2 ) Recommended: OS: Windows 10+ x64 CPU: 4th generation or later i5/i7 64-bit x86 processor with AVX(2) support GPU: GTX 980 Ti or later RAM: 6GB or more Microsoft Visual C++ Redistributable Minimum: OS: Windows 7+ x64 (Linux/macOS not natively supported) Windows <10 support is limited. Don't expect anything to work. Runs on Linux with Wine using Vulkan . CPU: 64-bit x86 processor with AVX(2) support GPU: Direct3D 12-compatible or Vulkan-compatible GPU from this list Direct3D 12 will only work on Windows 10 due to D3D12on7 and vkd3d not being supported. GPUs without ROV (rasterizer-ordered view) / fragment shader interlock support will perform worse and possibly have more graphical issues. Integrated GPUs will also generally provide frame rates too low for comfortable playing. AMD GPUs also fall under this due to Xenia triggering driver bugs causing crashes. RAM: 4GB The Latest x64 Visual C++ Redistributable Xenia doesn't require any Xbox 360 system files. Xenia will check for the minimum supported CPU and GPU on startup and error out if one is not detected. Make sure that you have the latest drivers installed. You cannot just remove the checks in the code and assume things will work. There are no magical workarounds to make Xenia work on your potato computer. OpenGL and Direct3D11 or lower are not, and never will be supported. Windows Update tends to lag behind, so download GPU drivers from your manufacturer: - AMD - NVIDIA - Intel Next section... Where to Download Xenia","title":"System Requirements"},{"location":"faq/quickstart/system_requirements/#system-requirements","text":"Meeting recommended specifications won't guarantee perfect performance. How to find relevant specs in Speccy on Windows On the first page, you'll find your operating system, CPU, GPU, and amount of RAM. On the CPU page, you'll find your CPU instruction extensions. (Look for AVX2 )","title":"System Requirements"},{"location":"faq/quickstart/system_requirements/#recommended","text":"OS: Windows 10+ x64 CPU: 4th generation or later i5/i7 64-bit x86 processor with AVX(2) support GPU: GTX 980 Ti or later RAM: 6GB or more Microsoft Visual C++ Redistributable","title":"Recommended:"},{"location":"faq/quickstart/system_requirements/#minimum","text":"OS: Windows 7+ x64 (Linux/macOS not natively supported) Windows <10 support is limited. Don't expect anything to work. Runs on Linux with Wine using Vulkan . CPU: 64-bit x86 processor with AVX(2) support GPU: Direct3D 12-compatible or Vulkan-compatible GPU from this list Direct3D 12 will only work on Windows 10 due to D3D12on7 and vkd3d not being supported. GPUs without ROV (rasterizer-ordered view) / fragment shader interlock support will perform worse and possibly have more graphical issues. Integrated GPUs will also generally provide frame rates too low for comfortable playing. AMD GPUs also fall under this due to Xenia triggering driver bugs causing crashes. RAM: 4GB The Latest x64 Visual C++ Redistributable Xenia doesn't require any Xbox 360 system files. Xenia will check for the minimum supported CPU and GPU on startup and error out if one is not detected. Make sure that you have the latest drivers installed. You cannot just remove the checks in the code and assume things will work. There are no magical workarounds to make Xenia work on your potato computer. OpenGL and Direct3D11 or lower are not, and never will be supported. Windows Update tends to lag behind, so download GPU drivers from your manufacturer: - AMD - NVIDIA - Intel Next section... Where to Download Xenia","title":"Minimum:"},{"location":"meta/","text":"About Xenia Wiki The Xenia Wiki is the official source of documentation for the Xenia project . Articles written here are contributed by members of the Xenia community, including the developers of Xenia themselves! If you would like to contribute to the project, you've come to the right place. Just click the link down below to learn how! Want to contribute to the wiki? See the contribution guide Contributors \u2728 Thanks goes to these wonderful people ( emoji key ): Caroline Joy Bell \ud83d\udcd6 \ud83d\udd8b \ud83c\udfa8 \ud83d\udcbb Margen67 \ud83d\udcd6 \ud83d\udd8b \ud83d\udcbb Billie \u26a0\ufe0f Satori \ud83d\udcbb This project follows the all-contributors specification. Contributions of any kind welcome!","title":"About Xenia Wiki"},{"location":"meta/#about-xenia-wiki","text":"The Xenia Wiki is the official source of documentation for the Xenia project . Articles written here are contributed by members of the Xenia community, including the developers of Xenia themselves! If you would like to contribute to the project, you've come to the right place. Just click the link down below to learn how! Want to contribute to the wiki? See the contribution guide","title":"About Xenia Wiki"},{"location":"meta/#contributors","text":"Thanks goes to these wonderful people ( emoji key ): Caroline Joy Bell \ud83d\udcd6 \ud83d\udd8b \ud83c\udfa8 \ud83d\udcbb Margen67 \ud83d\udcd6 \ud83d\udd8b \ud83d\udcbb Billie \u26a0\ufe0f Satori \ud83d\udcbb This project follows the all-contributors specification. Contributions of any kind welcome!","title":"Contributors \u2728"},{"location":"meta/contributing/","text":"Xenia Wiki Contribution Guide Prerequisites Prerequisites Knowledge and a copy of Git A GitHub account For testing You'll need MkDocs installed locally via Python to test your changes. Python 3.7+ Ensure Python gets added to your PATH MkDocs , and mkdocs-material : Run python -m pip install mkdocs mkdocs-material in your command prompt Instructions If this is your first time contributing, be sure to read this entire section before you begin. Clone the repo and open it in your favorite editor. If your editor creates editor-specific files, add them to the .gitignore file. Write your article using Markdown. The many features of Markdown extensions can be found in the links below. If you'd like to use a Markdown extension not listed in mkdocs.yml , you may add them to the list. You should ensure compatibility with other articles (so their layout does not accidentally change) before your changes are merged. PyMdown Extensions MkDocs Material Extensions Test and spell-check your article before it is merged. Submit a pull request to the wiki repo Testing To serve your copy of the website for testing: Run python -m mkdocs serve in your command prompt Open 127.0.0.1:8000 in your browser (be sure not to include http(s):// this will cause errors in the browser) If you get any errors, read them carefully. The most common errors are broken links. You may have typed them wrong. Keep in mind that / resolves to the docs folder. So, this page for example would be located at /meta/contributing Embedded images must have extensions. Links to documents on this Wiki must have extensions. Articles on the wiki are do not need .md extensions (except in mkdocs.yml ). Guidelines Never attach files or links to content that is private to another party. This includes leaked documentation (such as the XDK), piracy websites and other pirated content. If you attach a link to code on GitHub in your article, make sure to get the permalink. Attaching links to branches (such as master/main) leads to dead or incorrect links down the road! Tips Stumped on how to do something? These resources might help! MkDocs Material Setup Explains the setup of MkDocs Material sites, such as fonts, colors, and navigation . MkDocs Material Reference Includes details about the features of MkDocs Material, the theme used by Xenia Wiki. Want to know how to use features like emoji, tables, buttons, and diagrams? It's all in there. Xenia Discord Talking to developers may give you ideas for documentation. The #dev-references channel may have additional references to add to the wiki. Tools Xenia - You'll probably need it! Lightshot - An easy screenshot program for Windows and Mac Has a few more features than Snipping Tool, including automatic upload and a dedicated screenshot hotkey. Flameshot - Almost the same as Lightshot, but on Linux! Suggestions Config Options are often added updated, and could always use documentation. Additional languages can be supported. Although Xenia itself does not yet support multiple languages, the wiki can! If you would like to translate the wiki to your language, start here!","title":"Contribution Guide"},{"location":"meta/contributing/#xenia-wiki-contribution-guide","text":"Prerequisites","title":"Xenia Wiki Contribution Guide"},{"location":"meta/contributing/#prerequisites","text":"Knowledge and a copy of Git A GitHub account","title":"Prerequisites"},{"location":"meta/contributing/#for-testing","text":"You'll need MkDocs installed locally via Python to test your changes. Python 3.7+ Ensure Python gets added to your PATH MkDocs , and mkdocs-material : Run python -m pip install mkdocs mkdocs-material in your command prompt Instructions If this is your first time contributing, be sure to read this entire section before you begin. Clone the repo and open it in your favorite editor. If your editor creates editor-specific files, add them to the .gitignore file. Write your article using Markdown. The many features of Markdown extensions can be found in the links below. If you'd like to use a Markdown extension not listed in mkdocs.yml , you may add them to the list. You should ensure compatibility with other articles (so their layout does not accidentally change) before your changes are merged. PyMdown Extensions MkDocs Material Extensions Test and spell-check your article before it is merged. Submit a pull request to the wiki repo Testing To serve your copy of the website for testing: Run python -m mkdocs serve in your command prompt Open 127.0.0.1:8000 in your browser (be sure not to include http(s):// this will cause errors in the browser) If you get any errors, read them carefully. The most common errors are broken links. You may have typed them wrong. Keep in mind that / resolves to the docs folder. So, this page for example would be located at /meta/contributing Embedded images must have extensions. Links to documents on this Wiki must have extensions. Articles on the wiki are do not need .md extensions (except in mkdocs.yml ).","title":"For testing"},{"location":"meta/contributing/#guidelines","text":"Never attach files or links to content that is private to another party. This includes leaked documentation (such as the XDK), piracy websites and other pirated content. If you attach a link to code on GitHub in your article, make sure to get the permalink. Attaching links to branches (such as master/main) leads to dead or incorrect links down the road!","title":"Guidelines"},{"location":"meta/contributing/#tips","text":"Stumped on how to do something? These resources might help! MkDocs Material Setup Explains the setup of MkDocs Material sites, such as fonts, colors, and navigation . MkDocs Material Reference Includes details about the features of MkDocs Material, the theme used by Xenia Wiki. Want to know how to use features like emoji, tables, buttons, and diagrams? It's all in there. Xenia Discord Talking to developers may give you ideas for documentation. The #dev-references channel may have additional references to add to the wiki.","title":"Tips"},{"location":"meta/contributing/#tools","text":"Xenia - You'll probably need it! Lightshot - An easy screenshot program for Windows and Mac Has a few more features than Snipping Tool, including automatic upload and a dedicated screenshot hotkey. Flameshot - Almost the same as Lightshot, but on Linux!","title":"Tools"},{"location":"meta/contributing/#suggestions","text":"Config Options are often added updated, and could always use documentation. Additional languages can be supported. Although Xenia itself does not yet support multiple languages, the wiki can! If you would like to translate the wiki to your language, start here!","title":"Suggestions"}]}